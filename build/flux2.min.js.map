{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///flux2.min.js","webpack:///webpack/bootstrap bca32a7057b65786c497","webpack:///./index.js","webpack:///./lib/dispatcher.js","webpack:///./lib/create-store.js","webpack:///./~/eventemitter3/index.js","webpack:///./~/lodash.assign/index.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/immutable/dist/immutable.js","webpack:///./~/lodash.assign/~/lodash._baseassign/index.js","webpack:///./~/lodash.assign/~/lodash._createassigner/index.js","webpack:///./~/lodash.assign/~/lodash._baseassign/~/lodash._basecopy/index.js","webpack:///./~/lodash.assign/~/lodash._baseassign/~/lodash.keys/index.js","webpack:///./~/lodash.assign/~/lodash._createassigner/~/lodash._bindcallback/index.js","webpack:///./~/lodash.assign/~/lodash._createassigner/~/lodash._isiterateecall/index.js","webpack:///./~/lodash.assign/~/lodash._baseassign/~/lodash.keys/~/lodash.isarguments/index.js","webpack:///./~/lodash.assign/~/lodash._baseassign/~/lodash.keys/~/lodash.isarray/index.js","webpack:///./~/lodash.assign/~/lodash._baseassign/~/lodash.keys/~/lodash.isnative/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Dispatcher","createStore","debugLog","_registeredStoresByName","_registeredStoresByID","_lastRegisteredStoreID","register","callback","context","options","itemIdCounter","exists","collection","_","forOwn","collectionItem","registerOnce","once","dispatch","data","itemsToDelete","collectionItemId","apply","push","index","length","unregister","waitFor","chains","Array","isArray","counter","store","on","_onWaitForStoreChange","_registerStore","console","debug","name","_registeredStoreID","warn","_unregisterStore","identifier","getStore","getState","foundStore","state","setState","changes","chain","key","hasOwnProperty","ready","off","EventEmitter","inherites","assign","Immutable","Store","spec","getInitialState","_stateMap","Map","toJS","init","storeWillMount","cancel","storeDidMount","prototype","shouldStoreUpdate","prevState","newState","merge","storeWillUpdate","emit","storeDidUpdate","appendStore","mergedArrays","mergedValue","concat","EE","fn","_events","undefined","listeners","event","i","l","ee","a1","a2","a3","a4","a5","args","len","arguments","removeListener","j","listener","events","removeAllListeners","addListener","setMaxListeners","EventEmitter2","EventEmitter3","baseAssign","createAssigner","Object","create","ctor","superCtor","super_","constructor","value","enumerable","writable","configurable","TempCtor","global","createClass","superClass","MakeRef","ref","SetRef","OwnerID","arrCopy","arr","offset","Math","max","newArr","ii","ensureSize","iter","size","__iterate","returnTrue","wrapIndex","wholeSlice","begin","end","resolveBegin","resolveIndex","resolveEnd","defaultIndex","min","Iterable","isIterable","Seq","KeyedIterable","isKeyed","KeyedSeq","IndexedIterable","isIndexed","IndexedSeq","SetIterable","isAssociative","SetSeq","maybeIterable","IS_ITERABLE_SENTINEL","maybeKeyed","IS_KEYED_SENTINEL","maybeIndexed","IS_INDEXED_SENTINEL","maybeAssociative","isOrdered","maybeOrdered","IS_ORDERED_SENTINEL","Iterator","next","iteratorValue","type","k","v","iteratorResult","done","iteratorDone","hasIterator","getIteratorFn","isIterator","maybeIterator","getIterator","iterable","iteratorFn","REAL_ITERATOR_SYMBOL","FAUX_ITERATOR_SYMBOL","isArrayLike","emptySequence","toSeq","seqFromValue","toKeyedSeq","fromEntrySeq","keyedSeqFromValue","entrySeq","toIndexedSeq","indexedSeqFromValue","toSetSeq","ArraySeq","array","_array","ObjectSeq","object","keys","_object","_keys","IterableSeq","_iterable","IteratorSeq","iterator","_iterator","_iteratorCache","isSeq","maybeSeq","IS_SEQ_SENTINEL","EMPTY_SEQ","seq","TypeError","maybeIndexedSeqFromValue","seqIterate","reverse","useKeys","cache","_cache","maxIndex","entry","__iterateUncached","seqIterator","__iteratorUncached","Collection","KeyedCollection","IndexedCollection","SetCollection","is","valueA","valueB","valueOf","equals","fromJS","json","converter","fromJSWith","fromJSDefault","parentJSON","map","isPlainObj","toList","toMap","smi","i32","hash","o","h","STRING_HASH_CACHE_MIN_STRLEN","cachedHashString","hashString","hashCode","hashJSObj","string","stringHashCache","STRING_HASH_CACHE_SIZE","STRING_HASH_CACHE_MAX_SIZE","charCodeAt","obj","weakMap","get","UID_HASH_KEY","canDefineProperty","propertyIsEnumerable","getIENodeHash","isExtensible","Error","objHashUID","set","defineProperty","nodeType","node","uniqueID","documentElement","invariant","condition","error","assertNotInfinite","Infinity","ToKeyedSequence","indexed","_iter","_useKeys","ToIndexedSequence","ToSetSequence","FromEntriesSequence","entries","flipFactory","flipSequence","makeSequence","flip","reversedSequence","has","contains","cacheResult","cacheResultThrough","this$0","ITERATE_ENTRIES","__iterator","step","ITERATE_VALUES","ITERATE_KEYS","mapFactory","mapper","mappedSequence","notSetValue","NOT_SET","reverseFactory","filterFactory","predicate","filterSequence","iterations","countByFactory","grouper","groups","asMutable","update","a","asImmutable","groupByFactory","isKeyedIter","OrderedMap","coerce","iterableClass","reify","sliceFactory","originalSize","resolvedBegin","resolvedEnd","sliceSize","sliceSeq","skipped","isSkipping","takeWhileFactory","takeSequence","iterating","skipWhileFactory","skipSequence","skipping","concatFactory","values","isKeyedIterable","iters","filter","singleton","concatSeq","flatten","reduce","sum","flattenFactory","depth","flatSequence","flatDeep","currentDepth","stopped","stack","pop","flatMapFactory","interposeFactory","separator","interposedSequence","sortFactory","comparator","defaultComparator","toArray","sort","b","forEach","maxFactory","maxCompare","comp","zipWithFactory","keyIter","zipper","zipSequence","iterators","isDone","steps","some","s","validateEntry","resolveSize","forceIterator","keyPath","emptyMap","isMap","withMutations","maybeMap","IS_MAP_SENTINEL","ArrayMapNode","ownerID","BitmapIndexedNode","bitmap","nodes","HashArrayMapNode","count","HashCollisionNode","keyHash","ValueNode","MapIterator","_type","_reverse","_stack","_root","mapIteratorFrame","mapIteratorValue","prev","__prev","makeMap","MapPrototype","__ownerID","__hash","__altered","EMPTY_MAP","updateMap","newRoot","newSize","didChangeSize","CHANGE_LENGTH","didAlter","DID_ALTER","updateNode","shift","isLeafNode","mergeIntoNode","newNode","idx1","MASK","idx2","SHIFT","createNodes","packNodes","excluding","packedII","packedNodes","bit","expandNodes","including","expandedNodes","SIZE","mergeIntoMapWith","merger","iterables","mergeIntoCollectionWith","deepMerger","existing","mergeDeepWith","x","mergeIntoMap","updateInDeepMap","keyPathIter","updater","isNotSet","existingValue","newValue","nextExisting","nextUpdated","remove","popCount","setIn","idx","val","canEdit","newArray","spliceIn","newLen","after","spliceOut","List","empty","emptyList","isList","makeList","VNode","list","setSize","maybeList","IS_LIST_SENTINEL","iterateList","iterateNodeOrLeaf","level","iterateLeaf","iterateNode","tailPos","tail","from","left","to","right","DONE","_origin","_capacity","getTailOffset","_tail","_level","origin","capacity","ListPrototype","EMPTY_LIST","updateList","setListBounds","newTail","updateVNode","nodeHas","lowerNode","newLowerNode","editableVNode","slice","listNodeFor","rawIndex","owner","oldOrigin","oldCapacity","newOrigin","newCapacity","clear","newLevel","offsetShift","oldTailOffset","newTailOffset","oldTail","removeAfter","removeBefore","beginIndex","mergeIntoListWith","maxSize","emptyOrderedMap","isOrderedMap","maybeOrderedMap","makeOrderedMap","omap","_map","_list","EMPTY_ORDERED_MAP","updateOrderedMap","newMap","newList","Stack","emptyStack","isStack","unshiftAll","maybeStack","IS_STACK_SENTINEL","makeStack","head","StackPrototype","_head","EMPTY_STACK","Set","emptySet","isSet","add","maybeSet","IS_SET_SENTINEL","updateSet","__empty","__make","makeSet","SetPrototype","EMPTY_SET","OrderedSet","emptyOrderedSet","isOrderedSet","maybeOrderedSet","makeOrderedSet","OrderedSetPrototype","EMPTY_ORDERED_SET","Record","defaultValues","RecordType","RecordTypePrototype","RecordPrototype","_name","_defaultValues","makeRecord","likeRecord","record","getPrototypeOf","recordName","deepEqual","notAssociative","every","flipped","allEqual","bSize","Range","start","abs","_start","_end","_step","ceil","EMPTY_RANGE","Repeat","times","_value","EMPTY_REPEAT","mixin","methods","keyCopier","getOwnPropertySymbols","keyMapper","entryMapper","not","neg","quoteString","JSON","stringify","defaultZipper","defaultNegComparator","hashIterable","ordered","keyed","hashMerge","murmurHashOfSize","Math__imul","SLICE$0","DELETE","Keyed","Indexed","Symbol","ITERATOR_SYMBOL","toString","KEYS","VALUES","ENTRIES","inspect","toSource","of","__toString","imul","d","e","WeakMap","valueSeq","updateIn","deleteIn","updatedValue","mergeWith","mergeIn","mergeDeep","mergeDeepIn","sortBy","mutable","wasAltered","__ensureOwner","iterate","removeIn","removed","MAX_ARRAY_MAP_SIZE","isEditable","newEntries","keyHashFrag","MAX_BITMAP_INDEXED_SIZE","newBitmap","newNodes","newCount","MIN_HASH_ARRAY_MAP_SIZE","keyMatch","subNode","splice","oldSize","unshift","originIndex","newChild","removingFirst","oldChild","editable","sizeIndex","removingLast","peek","pushAll","fromKeys","keySeq","union","intersect","originalSet","subtract","defaultVal","SuperRecord","_empty","searchValue","possibleIndex","floor","indexOf","offsetValue","lastIndexOf","other","__toJS","toJSON","toObject","toOrderedMap","toOrderedSet","toSet","toStack","__toStringMapper","join","returnValue","find","findEntry","found","findLastEntry","sideEffect","bind","joined","isFirst","reducer","initialReduction","reduction","useFirst","reduceRight","reversed","butLast","isEmpty","countBy","entriesSequence","filterNot","findLast","first","flatMap","searchKey","getIn","searchKeyPath","nested","groupBy","hasIn","isSubset","isSuperset","last","maxBy","minBy","rest","skip","amount","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","IterablePrototype","noLengthWarning","findKey","findLastKey","keyOf","lastKeyOf","mapEntries","mapKeys","KeyedIterablePrototype","findIndex","removeNum","numArgs","spliced","findLastIndex","interpose","interleave","zipped","interleaved","zip","zipWith","source","customizer","props","baseCopy","result","assigner","isIterateeCall","bindCallback","isIndex","MAX_SAFE_INTEGER","isLength","shimKeys","keysIn","propsLength","allowIndexes","support","nonEnumArgs","isArguments","isObject","Ctor","isProto","skipIndexes","isNative","objectProto","nativeKeys","pow","func","thisArg","argCount","identity","accumulator","prereq","isObjectLike","objToString","argsTag","baseToString","funcTag","reNative","test","fnToString","reHostCtor","escapeRegExp","reHasRegExpChars","replace","reRegExpChars","arrayTag","RegExp","Function","nativeIsArray"],"mappings":"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","file":"flux2.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Flux2\"] = factory();\n\telse\n\t\troot[\"Flux2\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Flux2\"] = factory();\n\telse\n\t\troot[\"Flux2\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global require, module */\n\t'use strict';\n\tvar Dispatcher = __webpack_require__(1);\n\tvar createStore = __webpack_require__(2);\n\t\n\tmodule.exports = {\n\t    Dispatcher: Dispatcher,\n\t    createStore: createStore(Dispatcher)\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global require, module */\n\t'use strict';\n\t\n\t// @todo make [id] argument as an optional\n\tmodule.exports = {\n\t    /**\n\t     * Turn on to enable logging\n\t     * @type {boolean}\n\t     */\n\t    debugLog: false,\n\t    /**\n\t     * Hash of registered stores (indexed by `name` property)\n\t     * @type {object}\n\t     * @private\n\t     */\n\t    _registeredStoresByName: {},\n\t    /**\n\t     * Hash of registered stores (indexed by `_ID` property)\n\t     * @type {object}\n\t     * @private\n\t     */\n\t    _registeredStoresByID: {},\n\t    /**\n\t     * @type {number}\n\t     * @private\n\t     */\n\t    _lastRegisteredStoreID: 0,\n\t    /**\n\t     * @param {string} id of collection\n\t     * @param {function} callback which can return Promise object\n\t     * @param {object} [context]\n\t     * @param {object} [options]\n\t     * @param {boolean} [options.once=false]\n\t     * @param {boolean} [options.fullState=false]\n\t     * @returns {object} this\n\t     */\n\t    register: function (id, callback, context, options) {\n\t        this['callbacks'] = this['callbacks'] || {};\n\t        var itemIdCounter = this['callbacksSubscriberIdCounter'] || 1;\n\t        var exists = false;\n\t        var collection = this['callbacks'][id] || {};\n\t        _.forOwn(collection, function (collectionItem) {\n\t            if (collectionItem && collectionItem.callback === callback) {\n\t                exists = true;\n\t            }\n\t        });\n\t        if (!exists) {\n\t            collection[itemIdCounter++] = {\n\t                callback: callback,\n\t                context: context || this,\n\t                options: (typeof options === 'object') || {}\n\t            };\n\t            this['callbacks'][id] = collection;\n\t            this['callbacksSubscriberIdCounter'] = itemIdCounter;\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * @param {string} id of collection\n\t     * @param {function} callback\n\t     * @param {object} [context]\n\t     * @returns {object} this\n\t     */\n\t    registerOnce: function (id, callback, context) {\n\t        this.register(id, callback, context, {once: true});\n\t    },\n\t\n\t    /**\n\t     * @param {string|object[]} id of action or a collection {action: '', data: {}}\n\t     * @param {object} [data] to action\n\t     * @returns {object} this\n\t     * @todo support promises as a return value\n\t     */\n\t    dispatch: function (id, data) {\n\t        if (this['callbacks'] && this['callbacks'][id]) {\n\t\n\t            var collection = this['callbacks'][id];\n\t            var itemsToDelete = [];\n\t\n\t            _.forOwn(collection, function (collectionItem, collectionItemId) {\n\t                if (collectionItem && typeof collectionItem.callback === 'function') {\n\t                    collectionItem.callback.apply(collectionItem.context, data && [data]);\n\t                    if (collectionItem.options.once) {\n\t                        itemsToDelete.push(collectionItemId);\n\t                    }\n\t                }\n\t            });\n\t            for (var index = 0, length = itemsToDelete.length; index < length; index++) {\n\t                delete collection[itemsToDelete[index]];\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * @param {string} id of collection\n\t     * @param {function} callback\n\t     * @returns {object} this\n\t     */\n\t    unregister: function (id, callback) {\n\t        if (this['callbacks'] && this['callbacks'][id]) {\n\t            var collection = this['callbacks'][id];\n\t            _.forOwn(collection, function (collectionItem, id) {\n\t                if (collectionItem.callback === callback) {\n\t                    delete collection[id];\n\t                }\n\t            });\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Provides wait for store changes feature\n\t     * @param {object|object[]} chains\n\t     * @param {object} [chains.store] store object\n\t     * @param {function} [chains.ready] callback which should return true when params are accepted\n\t     * @param {function} callback - calls when all parts in chain are accepted\n\t     * @example\n\t     *   Dispatcher.waitFor([{\n\t     *     store: commentsStore,\n\t     *     ready: function (params) {\n\t     *       return Array.isArray(params.comments);\n\t      *    }\n\t      *  }, {\n\t      *    store: activeUsersStore,\n\t      *    ready: function (params) {\n\t      *      return Array.isArray(params.users);\n\t      *    }\n\t      *  }], function () {\n\t      *    React.render(\n\t      *      React.createElement(MainPage, null),\n\t      *      document.body\n\t      *    );\n\t      *  });\n\t     */\n\t    waitFor: function (chains, callback) {\n\t        var chains = Array.isArray(chains) ? chains : [chains];\n\t        var context = {\n\t            counter: 0,\n\t            chains: chains,\n\t            callback: callback\n\t        };\n\t        for (var index = 0, length = chains.length; index < length; index++) {\n\t            context.counter++;\n\t            chains[index].store.on('change', _onWaitForStoreChange, context);\n\t        }\n\t        if (context.counter === 0 && typeof callback === 'function') {\n\t            callback();\n\t        }\n\t    },\n\t    /**\n\t     * @param {object} store\n\t     * @returns {number} id of registered store\n\t     */\n\t    _registerStore: function (store) {\n\t        if (this.debugLog && console.debug) {\n\t            console.debug('Dispatcher.registerStore(%s)', store.name || 'unknown', store);\n\t        }\n\t        this._lastRegisteredStoreID++;\n\t        store._registeredStoreID = this._lastRegisteredStoreID;\n\t        this._registeredStoresByID[store._registeredStoreID] = store;\n\t        if (typeof store.name !== 'undefined') {\n\t            var name = store.name;\n\t            if (this._registeredStoresByName[name]) {\n\t                if (this._registeredStoresByName[name] !== store) {\n\t                    if (console.warn) {\n\t                        console.warn(\n\t                            'Another store with specified name \"%s\" is already registered.',\n\t                            name,\n\t                            this._registeredStoresByName[name]\n\t                        );\n\t                    }\n\t                }\n\t            } else {\n\t                this._registeredStoresByName[name] = store;\n\t            }\n\t        }\n\t    },\n\t    /**\n\t     * @param {string|number} identifier - name or id of store\n\t     */\n\t    _unregisterStore: function (identifier) {\n\t        var store = this.getStore(identifier);\n\t        if (this.debugLog && console.debug) {\n\t            console.debug('Dispatcher.unregisterStore(%s)', store.name || 'unknown', store);\n\t        }\n\t        if (store.name) {\n\t            delete this._registeredStoresByName[store.name];\n\t        }\n\t        if (store._registeredStoreID) {\n\t            delete this._registeredStoresByID[store._registeredStoreID];\n\t        }\n\t    },\n\t    /**\n\t     * Returns object of specified store\n\t     * @param {string|number} identifier - name or id of store\n\t     * @returns {object} found store or false\n\t     */\n\t    getStore: function (identifier) {\n\t        if (typeof identifier === 'number' &&\n\t                this._registeredStoresByID[identifier]) {\n\t            return this._registeredStoresByID[identifier];\n\t        } else if (this._registeredStoresByName[identifier]) {\n\t            return this._registeredStoresByName[identifier];\n\t        } else {\n\t            return false;\n\t        }\n\t    },\n\t    /**\n\t     * Returns `state` property of specified store\n\t     * @param {string|number} identifier - name or id of store\n\t     */\n\t    getState: function (identifier) {\n\t        var foundStore = this.getStore(identifier);\n\t        if (typeof foundStore === 'object') {\n\t            return foundStore.state;\n\t        } else {\n\t            return false;\n\t        }\n\t    },\n\t    /**\n\t     * Set state of specified store\n\t     * @param {string|number} identifier - name or id of store\n\t     * @param {object} state\n\t     */\n\t    setState: function (identifier, state) {\n\t        if (this.debugLog && console.debug) {\n\t            console.debug('Dispatcher.setState(%s)', identifier, state);\n\t        }\n\t        var foundStore = this.getStore(identifier);\n\t        if (foundStore.name) {\n\t            this.dispatch('set' + foundStore.name + 'State', state);\n\t        }\n\t        this.dispatch('setStore' + foundStore._registeredStoreID + 'State', state);\n\t        foundStore.setState(state);\n\t    }\n\t};\n\t/**\n\t * Uses by waitFor() method\n\t * @param {Object} changes\n\t * @private\n\t */\n\tvar _onWaitForStoreChange = function (changes) {\n\t    var chain;\n\t    for (var key in this.chains) {\n\t        chain = this.chains[key];\n\t        if (!this.chains.hasOwnProperty(key) || chain.store !== this) {\n\t            continue;\n\t        }\n\t        if (chain.ready(changes)) {\n\t            chain.store.off('change', _onWaitForStoreChange);\n\t            chain.counter--;\n\t            if (chain.counter < 1 && typeof callback === 'function') {\n\t                chain.callback();\n\t            }\n\t        }\n\t        break;\n\t    }\n\t};\n\t\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global require, module */\n\tvar EventEmitter = __webpack_require__(3);\n\tvar inherites = __webpack_require__(5);\n\tvar assign = __webpack_require__(4);\n\tvar Immutable = __webpack_require__(6);\n\t\n\t/**\n\t * @param {Object} Dispatcher\n\t * @returns {Function}\n\t */\n\tmodule.exports = function (Dispatcher) {\n\t    /**\n\t     * Creates a store instance\n\t     * @constructor\n\t     * @param {object} spec\n\t     * @param {string} [spec.name]\n\t     * @param {function} [spec.getInitialState]\n\t     * @parma {function} [spec.storeWillMount]\n\t     * @parma {function} [spec.storeDidMount]\n\t     * @param {function} [spec.shouldStoreUpdate]\n\t     * @param {function} [spec.storeWillUpdate]\n\t     * @param {function} [spec.storeDidUpdate]\n\t     * @returns {object} instance\n\t     */\n\t    var Store = function (spec) {\n\t        assign(this, spec);\n\t        if (typeof this.getInitialState === 'function') {\n\t            this._stateMap = Immutable.Map(this.getInitialState());\n\t            this.state = this._stateMap.toJS();\n\t        } else {\n\t            this._stateMap = Immutable.Map({});\n\t            this.state = {};\n\t        }\n\t        if (typeof this.init !== 'undefined') {\n\t            this.init();\n\t            if (console.warn) {\n\t                console.warn(\n\t                    'You use deprecated property init() to construct store. ' +\n\t                    'Please use getInitialState() instead.',\n\t                    this\n\t                );\n\t            }\n\t        }\n\t        if (typeof this.storeWillMount === 'function') {\n\t            var cancel = this.storeWillMount();\n\t            if (cancel) {\n\t                return null;\n\t            }\n\t        }\n\t        Dispatcher._registerStore(this);\n\t        if (typeof this.storeDidMount === 'function') {\n\t            this.storeDidMount();\n\t        }\n\t    };\n\t    inherites(Store, EventEmitter);\n\t    /**\n\t     * @param {Boolean} state\n\t     * @returns {boolean}\n\t     */\n\t    Store.prototype.setState = function (state) {\n\t        if (typeof this.shouldStoreUpdate === 'function') {\n\t            if (!this.shouldStoreUpdate(state)) {\n\t                return false;\n\t            }\n\t        }\n\t        var prevState = this._stateMap;\n\t        var newState = prevState.merge(state);\n\t        if (typeof this.storeWillUpdate === 'function') {\n\t            this.storeWillUpdate(newState);\n\t        }\n\t        this._stateMap = newState;\n\t        this.state = newState.toJS();\n\t        this.emit('change', newState);\n\t        if (typeof this.storeDidUpdate === 'function') {\n\t            this.storeDidUpdate(prevState.toJS());\n\t        }\n\t    };\n\t    Store.prototype.appendStore = function (changes) {\n\t        var state = this._stateMap.toJS();\n\t        var mergedArrays = {};\n\t        for (var key in changes) {\n\t            if (!changes.hasOwnProperty(key)) continue;\n\t            if (Array.isArray(changes[key]) &&\n\t                Array.isArray(state[key])) {\n\t                var mergedValue = state[key].concat(changes[key]);\n\t                mergedArrays[key] = mergedValue;\n\t            }\n\t        }\n\t        var newState = this._stateMap.merge(state, changes, mergedArrays);\n\t        this.setState(newState);\n\t    };\n\t    return function (spec) {\n\t        return new Store(spec);\n\t    };\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Representation of a single EventEmitter function.\n\t *\n\t * @param {Function} fn Event handler to be called.\n\t * @param {Mixed} context Context for function execution.\n\t * @param {Boolean} once Only emit once\n\t * @api private\n\t */\n\tfunction EE(fn, context, once) {\n\t  this.fn = fn;\n\t  this.context = context;\n\t  this.once = once || false;\n\t}\n\t\n\t/**\n\t * Minimal EventEmitter interface that is molded against the Node.js\n\t * EventEmitter interface.\n\t *\n\t * @constructor\n\t * @api public\n\t */\n\tfunction EventEmitter() { /* Nothing to set */ }\n\t\n\t/**\n\t * Holds the assigned EventEmitters by name.\n\t *\n\t * @type {Object}\n\t * @private\n\t */\n\tEventEmitter.prototype._events = undefined;\n\t\n\t/**\n\t * Return a list of assigned event listeners.\n\t *\n\t * @param {String} event The events that should be listed.\n\t * @returns {Array}\n\t * @api public\n\t */\n\tEventEmitter.prototype.listeners = function listeners(event) {\n\t  if (!this._events || !this._events[event]) return [];\n\t  if (this._events[event].fn) return [this._events[event].fn];\n\t\n\t  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {\n\t    ee[i] = this._events[event][i].fn;\n\t  }\n\t\n\t  return ee;\n\t};\n\t\n\t/**\n\t * Emit an event to all registered event listeners.\n\t *\n\t * @param {String} event The name of the event.\n\t * @returns {Boolean} Indication if we've emitted an event.\n\t * @api public\n\t */\n\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t  if (!this._events || !this._events[event]) return false;\n\t\n\t  var listeners = this._events[event]\n\t    , len = arguments.length\n\t    , args\n\t    , i;\n\t\n\t  if ('function' === typeof listeners.fn) {\n\t    if (listeners.once) this.removeListener(event, listeners.fn, true);\n\t\n\t    switch (len) {\n\t      case 1: return listeners.fn.call(listeners.context), true;\n\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t    }\n\t\n\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t      args[i - 1] = arguments[i];\n\t    }\n\t\n\t    listeners.fn.apply(listeners.context, args);\n\t  } else {\n\t    var length = listeners.length\n\t      , j;\n\t\n\t    for (i = 0; i < length; i++) {\n\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\t\n\t      switch (len) {\n\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t        default:\n\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t            args[j - 1] = arguments[j];\n\t          }\n\t\n\t          listeners[i].fn.apply(listeners[i].context, args);\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * Register a new EventListener for the given event.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Functon} fn Callback function.\n\t * @param {Mixed} context The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t  var listener = new EE(fn, context || this);\n\t\n\t  if (!this._events) this._events = {};\n\t  if (!this._events[event]) this._events[event] = listener;\n\t  else {\n\t    if (!this._events[event].fn) this._events[event].push(listener);\n\t    else this._events[event] = [\n\t      this._events[event], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add an EventListener that's only called once.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Function} fn Callback function.\n\t * @param {Mixed} context The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t  var listener = new EE(fn, context || this, true);\n\t\n\t  if (!this._events) this._events = {};\n\t  if (!this._events[event]) this._events[event] = listener;\n\t  else {\n\t    if (!this._events[event].fn) this._events[event].push(listener);\n\t    else this._events[event] = [\n\t      this._events[event], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove event listeners.\n\t *\n\t * @param {String} event The event we want to remove.\n\t * @param {Function} fn The listener that we need to find.\n\t * @param {Boolean} once Only remove once listeners.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n\t  if (!this._events || !this._events[event]) return this;\n\t\n\t  var listeners = this._events[event]\n\t    , events = [];\n\t\n\t  if (fn) {\n\t    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {\n\t      events.push(listeners);\n\t    }\n\t    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {\n\t      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {\n\t        events.push(listeners[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  //\n\t  // Reset the array, or remove it completely if we have no more listeners.\n\t  //\n\t  if (events.length) {\n\t    this._events[event] = events.length === 1 ? events[0] : events;\n\t  } else {\n\t    delete this._events[event];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove all listeners or only the listeners for the specified event.\n\t *\n\t * @param {String} event The event want to remove all listeners for.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t  if (!this._events) return this;\n\t\n\t  if (event) delete this._events[event];\n\t  else this._events = {};\n\t\n\t  return this;\n\t};\n\t\n\t//\n\t// Alias methods names because people roll like that.\n\t//\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t//\n\t// This function doesn't apply anymore.\n\t//\n\tEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n\t  return this;\n\t};\n\t\n\t//\n\t// Expose the module.\n\t//\n\tEventEmitter.EventEmitter = EventEmitter;\n\tEventEmitter.EventEmitter2 = EventEmitter;\n\tEventEmitter.EventEmitter3 = EventEmitter;\n\t\n\t//\n\t// Expose the module.\n\t//\n\tmodule.exports = EventEmitter;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\tvar baseAssign = __webpack_require__(7),\n\t    createAssigner = __webpack_require__(8);\n\t\n\t/**\n\t * Assigns own enumerable properties of source object(s) to the destination\n\t * object. Subsequent sources overwrite property assignments of previous sources.\n\t * If `customizer` is provided it is invoked to produce the assigned values.\n\t * The `customizer` is bound to `thisArg` and invoked with five arguments;\n\t * (objectValue, sourceValue, key, object, source).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @alias extend\n\t * @category Object\n\t * @param {Object} object The destination object.\n\t * @param {...Object} [sources] The source objects.\n\t * @param {Function} [customizer] The function to customize assigning values.\n\t * @param {*} [thisArg] The `this` binding of `customizer`.\n\t * @returns {Object} Returns `object`.\n\t * @example\n\t *\n\t * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n\t * // => { 'user': 'fred', 'age': 40 }\n\t *\n\t * // using a customizer callback\n\t * var defaults = _.partialRight(_.assign, function(value, other) {\n\t *   return typeof value == 'undefined' ? other : value;\n\t * });\n\t *\n\t * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n\t * // => { 'user': 'barney', 'age': 36 }\n\t */\n\tvar assign = createAssigner(baseAssign);\n\t\n\tmodule.exports = assign;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2014, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t(function (global, factory) {\n\t  true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  global.Immutable = factory()\n\t}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\t\n\t  function createClass(ctor, superClass) {\n\t    if (superClass) {\n\t      ctor.prototype = Object.create(superClass.prototype);\n\t    }\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\t\n\t  // Used for setting prototype methods that IE8 chokes on.\n\t  var DELETE = 'delete';\n\t\n\t  // Constants describing the size of trie nodes.\n\t  var SHIFT = 5; // Resulted in best performance after ______?\n\t  var SIZE = 1 << SHIFT;\n\t  var MASK = SIZE - 1;\n\t\n\t  // A consistent shared value representing \"not set\" which equals nothing other\n\t  // than itself, and nothing that could be provided externally.\n\t  var NOT_SET = {};\n\t\n\t  // Boolean references, Rough equivalent of `bool &`.\n\t  var CHANGE_LENGTH = { value: false };\n\t  var DID_ALTER = { value: false };\n\t\n\t  function MakeRef(ref) {\n\t    ref.value = false;\n\t    return ref;\n\t  }\n\t\n\t  function SetRef(ref) {\n\t    ref && (ref.value = true);\n\t  }\n\t\n\t  // A function which returns a value representing an \"owner\" for transient writes\n\t  // to tries. The return value will only ever equal itself, and will not equal\n\t  // the return of any subsequent call of this function.\n\t  function OwnerID() {}\n\t\n\t  // http://jsperf.com/copy-array-inline\n\t  function arrCopy(arr, offset) {\n\t    offset = offset || 0;\n\t    var len = Math.max(0, arr.length - offset);\n\t    var newArr = new Array(len);\n\t    for (var ii = 0; ii < len; ii++) {\n\t      newArr[ii] = arr[ii + offset];\n\t    }\n\t    return newArr;\n\t  }\n\t\n\t  function ensureSize(iter) {\n\t    if (iter.size === undefined) {\n\t      iter.size = iter.__iterate(returnTrue);\n\t    }\n\t    return iter.size;\n\t  }\n\t\n\t  function wrapIndex(iter, index) {\n\t    return index >= 0 ? (+index) : ensureSize(iter) + (+index);\n\t  }\n\t\n\t  function returnTrue() {\n\t    return true;\n\t  }\n\t\n\t  function wholeSlice(begin, end, size) {\n\t    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n\t      (end === undefined || (size !== undefined && end >= size));\n\t  }\n\t\n\t  function resolveBegin(begin, size) {\n\t    return resolveIndex(begin, size, 0);\n\t  }\n\t\n\t  function resolveEnd(end, size) {\n\t    return resolveIndex(end, size, size);\n\t  }\n\t\n\t  function resolveIndex(index, size, defaultIndex) {\n\t    return index === undefined ?\n\t      defaultIndex :\n\t      index < 0 ?\n\t        Math.max(0, size + index) :\n\t        size === undefined ?\n\t          index :\n\t          Math.min(size, index);\n\t  }\n\t\n\t  function Iterable(value) {\n\t      return isIterable(value) ? value : Seq(value);\n\t    }\n\t\n\t\n\t  createClass(KeyedIterable, Iterable);\n\t    function KeyedIterable(value) {\n\t      return isKeyed(value) ? value : KeyedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(IndexedIterable, Iterable);\n\t    function IndexedIterable(value) {\n\t      return isIndexed(value) ? value : IndexedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(SetIterable, Iterable);\n\t    function SetIterable(value) {\n\t      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n\t    }\n\t\n\t\n\t\n\t  function isIterable(maybeIterable) {\n\t    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n\t  }\n\t\n\t  function isKeyed(maybeKeyed) {\n\t    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n\t  }\n\t\n\t  function isIndexed(maybeIndexed) {\n\t    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n\t  }\n\t\n\t  function isAssociative(maybeAssociative) {\n\t    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n\t  }\n\t\n\t  function isOrdered(maybeOrdered) {\n\t    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n\t  }\n\t\n\t  Iterable.isIterable = isIterable;\n\t  Iterable.isKeyed = isKeyed;\n\t  Iterable.isIndexed = isIndexed;\n\t  Iterable.isAssociative = isAssociative;\n\t  Iterable.isOrdered = isOrdered;\n\t\n\t  Iterable.Keyed = KeyedIterable;\n\t  Iterable.Indexed = IndexedIterable;\n\t  Iterable.Set = SetIterable;\n\t\n\t\n\t  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  /* global Symbol */\n\t\n\t  var ITERATE_KEYS = 0;\n\t  var ITERATE_VALUES = 1;\n\t  var ITERATE_ENTRIES = 2;\n\t\n\t  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n\t  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\t\n\t  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\t\n\t\n\t  function Iterator(next) {\n\t      this.next = next;\n\t    }\n\t\n\t    Iterator.prototype.toString = function() {\n\t      return '[Iterator]';\n\t    };\n\t\n\t\n\t  Iterator.KEYS = ITERATE_KEYS;\n\t  Iterator.VALUES = ITERATE_VALUES;\n\t  Iterator.ENTRIES = ITERATE_ENTRIES;\n\t\n\t  Iterator.prototype.inspect =\n\t  Iterator.prototype.toSource = function () { return this.toString(); }\n\t  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n\t    return this;\n\t  };\n\t\n\t\n\t  function iteratorValue(type, k, v, iteratorResult) {\n\t    var value = type === 0 ? k : type === 1 ? v : [k, v];\n\t    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n\t      value: value, done: false\n\t    });\n\t    return iteratorResult;\n\t  }\n\t\n\t  function iteratorDone() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  function hasIterator(maybeIterable) {\n\t    return !!getIteratorFn(maybeIterable);\n\t  }\n\t\n\t  function isIterator(maybeIterator) {\n\t    return maybeIterator && typeof maybeIterator.next === 'function';\n\t  }\n\t\n\t  function getIterator(iterable) {\n\t    var iteratorFn = getIteratorFn(iterable);\n\t    return iteratorFn && iteratorFn.call(iterable);\n\t  }\n\t\n\t  function getIteratorFn(iterable) {\n\t    var iteratorFn = iterable && (\n\t      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n\t      iterable[FAUX_ITERATOR_SYMBOL]\n\t    );\n\t    if (typeof iteratorFn === 'function') {\n\t      return iteratorFn;\n\t    }\n\t  }\n\t\n\t  function isArrayLike(value) {\n\t    return value && typeof value.length === 'number';\n\t  }\n\t\n\t  createClass(Seq, Iterable);\n\t    function Seq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        isIterable(value) ? value.toSeq() : seqFromValue(value);\n\t    }\n\t\n\t    Seq.of = function(/*...values*/) {\n\t      return Seq(arguments);\n\t    };\n\t\n\t    Seq.prototype.toSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    Seq.prototype.toString = function() {\n\t      return this.__toString('Seq {', '}');\n\t    };\n\t\n\t    Seq.prototype.cacheResult = function() {\n\t      if (!this._cache && this.__iterateUncached) {\n\t        this._cache = this.entrySeq().toArray();\n\t        this.size = this._cache.length;\n\t      }\n\t      return this;\n\t    };\n\t\n\t    // abstract __iterateUncached(fn, reverse)\n\t\n\t    Seq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, true);\n\t    };\n\t\n\t    // abstract __iteratorUncached(type, reverse)\n\t\n\t    Seq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, true);\n\t    };\n\t\n\t\n\t\n\t  createClass(KeyedSeq, Seq);\n\t    function KeyedSeq(value) {\n\t      return value === null || value === undefined ?\n\t        emptySequence().toKeyedSeq() :\n\t        isIterable(value) ?\n\t          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n\t          keyedSeqFromValue(value);\n\t    }\n\t\n\t    KeyedSeq.of = function(/*...values*/) {\n\t      return KeyedSeq(arguments);\n\t    };\n\t\n\t    KeyedSeq.prototype.toKeyedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    KeyedSeq.prototype.toSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  createClass(IndexedSeq, Seq);\n\t    function IndexedSeq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n\t    }\n\t\n\t    IndexedSeq.of = function(/*...values*/) {\n\t      return IndexedSeq(arguments);\n\t    };\n\t\n\t    IndexedSeq.prototype.toIndexedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    IndexedSeq.prototype.toString = function() {\n\t      return this.__toString('Seq [', ']');\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, false);\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, false);\n\t    };\n\t\n\t\n\t\n\t  createClass(SetSeq, Seq);\n\t    function SetSeq(value) {\n\t      return (\n\t        value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value\n\t      ).toSetSeq();\n\t    }\n\t\n\t    SetSeq.of = function(/*...values*/) {\n\t      return SetSeq(arguments);\n\t    };\n\t\n\t    SetSeq.prototype.toSetSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  Seq.isSeq = isSeq;\n\t  Seq.Keyed = KeyedSeq;\n\t  Seq.Set = SetSeq;\n\t  Seq.Indexed = IndexedSeq;\n\t\n\t  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\t\n\t  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\t\n\t\n\t\n\t  // #pragma Root Sequences\n\t\n\t  createClass(ArraySeq, IndexedSeq);\n\t    function ArraySeq(array) {\n\t      this._array = array;\n\t      this.size = array.length;\n\t    }\n\t\n\t    ArraySeq.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterate = function(fn, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterator = function(type, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n\t      );\n\t    };\n\t\n\t\n\t\n\t  createClass(ObjectSeq, KeyedSeq);\n\t    function ObjectSeq(object) {\n\t      var keys = Object.keys(object);\n\t      this._object = object;\n\t      this._keys = keys;\n\t      this.size = keys.length;\n\t    }\n\t\n\t    ObjectSeq.prototype.get = function(key, notSetValue) {\n\t      if (notSetValue !== undefined && !this.has(key)) {\n\t        return notSetValue;\n\t      }\n\t      return this._object[key];\n\t    };\n\t\n\t    ObjectSeq.prototype.has = function(key) {\n\t      return this._object.hasOwnProperty(key);\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        if (fn(object[key], key, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterator = function(type, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, key, object[key]);\n\t      });\n\t    };\n\t\n\t  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(IterableSeq, IndexedSeq);\n\t    function IterableSeq(iterable) {\n\t      this._iterable = iterable;\n\t      this.size = iterable.length || iterable.size;\n\t    }\n\t\n\t    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      var iterations = 0;\n\t      if (isIterator(iterator)) {\n\t        var step;\n\t        while (!(step = iterator.next()).done) {\n\t          if (fn(step.value, iterations++, this) === false) {\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      if (!isIterator(iterator)) {\n\t        return new Iterator(iteratorDone);\n\t      }\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step : iteratorValue(type, iterations++, step.value);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(IteratorSeq, IndexedSeq);\n\t    function IteratorSeq(iterator) {\n\t      this._iterator = iterator;\n\t      this._iteratorCache = [];\n\t    }\n\t\n\t    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      while (iterations < cache.length) {\n\t        if (fn(cache[iterations], iterations++, this) === false) {\n\t          return iterations;\n\t        }\n\t      }\n\t      var step;\n\t      while (!(step = iterator.next()).done) {\n\t        var val = step.value;\n\t        cache[iterations] = val;\n\t        if (fn(val, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        if (iterations >= cache.length) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          cache[iterations] = step.value;\n\t        }\n\t        return iteratorValue(type, iterations, cache[iterations++]);\n\t      });\n\t    };\n\t\n\t\n\t\n\t\n\t  // # pragma Helper functions\n\t\n\t  function isSeq(maybeSeq) {\n\t    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n\t  }\n\t\n\t  var EMPTY_SEQ;\n\t\n\t  function emptySequence() {\n\t    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n\t  }\n\t\n\t  function keyedSeqFromValue(value) {\n\t    var seq =\n\t      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n\t      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n\t      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n\t      typeof value === 'object' ? new ObjectSeq(value) :\n\t      undefined;\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of [k, v] entries, '+\n\t        'or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function indexedSeqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value);\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function seqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value) ||\n\t      (typeof value === 'object' && new ObjectSeq(value));\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values, or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function maybeIndexedSeqFromValue(value) {\n\t    return (\n\t      isArrayLike(value) ? new ArraySeq(value) :\n\t      isIterator(value) ? new IteratorSeq(value) :\n\t      hasIterator(value) ? new IterableSeq(value) :\n\t      undefined\n\t    );\n\t  }\n\t\n\t  function seqIterate(seq, fn, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    }\n\t    return seq.__iterateUncached(fn, reverse);\n\t  }\n\t\n\t  function seqIterator(seq, type, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n\t      });\n\t    }\n\t    return seq.__iteratorUncached(type, reverse);\n\t  }\n\t\n\t  createClass(Collection, Iterable);\n\t    function Collection() {\n\t      throw TypeError('Abstract');\n\t    }\n\t\n\t\n\t  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\t\n\t  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\t\n\t  createClass(SetCollection, Collection);function SetCollection() {}\n\t\n\t\n\t  Collection.Keyed = KeyedCollection;\n\t  Collection.Indexed = IndexedCollection;\n\t  Collection.Set = SetCollection;\n\t\n\t  /**\n\t   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n\t   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n\t   *\n\t   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n\t   * value, which is different from the algorithm described by\n\t   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n\t   *\n\t   * This is extended further to allow Objects to describe the values they\n\t   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n\t   *\n\t   * Note: because of this extension, the key equality of Immutable.Map and the\n\t   * value equality of Immutable.Set will differ from ES6 Map and Set.\n\t   *\n\t   * ### Defining custom values\n\t   *\n\t   * The easiest way to describe the value an object represents is by implementing\n\t   * `valueOf`. For example, `Date` represents a value by returning a unix\n\t   * timestamp for `valueOf`:\n\t   *\n\t   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n\t   *     var date2 = new Date(1234567890000);\n\t   *     date1.valueOf(); // 1234567890000\n\t   *     assert( date1 !== date2 );\n\t   *     assert( Immutable.is( date1, date2 ) );\n\t   *\n\t   * Note: overriding `valueOf` may have other implications if you use this object\n\t   * where JavaScript expects a primitive, such as implicit string coercion.\n\t   *\n\t   * For more complex types, especially collections, implementing `valueOf` may\n\t   * not be performant. An alternative is to implement `equals` and `hashCode`.\n\t   *\n\t   * `equals` takes another object, presumably of similar type, and returns true\n\t   * if the it is equal. Equality is symmetrical, so the same result should be\n\t   * returned if this and the argument are flipped.\n\t   *\n\t   *     assert( a.equals(b) === b.equals(a) );\n\t   *\n\t   * `hashCode` returns a 32bit integer number representing the object which will\n\t   * be used to determine how to store the value object in a Map or Set. You must\n\t   * provide both or neither methods, one must not exist without the other.\n\t   *\n\t   * Also, an important relationship between these methods must be upheld: if two\n\t   * values are equal, they *must* return the same hashCode. If the values are not\n\t   * equal, they might have the same hashCode; this is called a hash collision,\n\t   * and while undesirable for performance reasons, it is acceptable.\n\t   *\n\t   *     if (a.equals(b)) {\n\t   *       assert( a.hashCode() === b.hashCode() );\n\t   *     }\n\t   *\n\t   * All Immutable collections implement `equals` and `hashCode`.\n\t   *\n\t   */\n\t  function is(valueA, valueB) {\n\t    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t      return true;\n\t    }\n\t    if (!valueA || !valueB) {\n\t      return false;\n\t    }\n\t    if (typeof valueA.valueOf === 'function' &&\n\t        typeof valueB.valueOf === 'function') {\n\t      valueA = valueA.valueOf();\n\t      valueB = valueB.valueOf();\n\t    }\n\t    return typeof valueA.equals === 'function' &&\n\t      typeof valueB.equals === 'function' ?\n\t        valueA.equals(valueB) :\n\t        valueA === valueB || (valueA !== valueA && valueB !== valueB);\n\t  }\n\t\n\t  function fromJS(json, converter) {\n\t    return converter ?\n\t      fromJSWith(converter, json, '', {'': json}) :\n\t      fromJSDefault(json);\n\t  }\n\t\n\t  function fromJSWith(converter, json, key, parentJSON) {\n\t    if (Array.isArray(json)) {\n\t      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function fromJSDefault(json) {\n\t    if (Array.isArray(json)) {\n\t      return IndexedSeq(json).map(fromJSDefault).toList();\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return KeyedSeq(json).map(fromJSDefault).toMap();\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function isPlainObj(value) {\n\t    return value && value.constructor === Object;\n\t  }\n\t\n\t  var Math__imul =\n\t    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n\t    Math.imul :\n\t    function Math__imul(a, b) {\n\t      a = a | 0; // int\n\t      b = b | 0; // int\n\t      var c = a & 0xffff;\n\t      var d = b & 0xffff;\n\t      // Shift by 0 fixes the sign on the high part.\n\t      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n\t    };\n\t\n\t  // v8 has an optimization for storing 31-bit signed numbers.\n\t  // Values which have either 00 or 11 as the high order bits qualify.\n\t  // This function drops the highest order bit in a signed number, maintaining\n\t  // the sign bit.\n\t  function smi(i32) {\n\t    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n\t  }\n\t\n\t  function hash(o) {\n\t    if (o === false || o === null || o === undefined) {\n\t      return 0;\n\t    }\n\t    if (typeof o.valueOf === 'function') {\n\t      o = o.valueOf();\n\t      if (o === false || o === null || o === undefined) {\n\t        return 0;\n\t      }\n\t    }\n\t    if (o === true) {\n\t      return 1;\n\t    }\n\t    var type = typeof o;\n\t    if (type === 'number') {\n\t      var h = o | 0;\n\t      if (h !== o) {\n\t        h ^= o * 0xFFFFFFFF;\n\t      }\n\t      while (o > 0xFFFFFFFF) {\n\t        o /= 0xFFFFFFFF;\n\t        h ^= o;\n\t      }\n\t      return smi(h);\n\t    }\n\t    if (type === 'string') {\n\t      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n\t    }\n\t    if (typeof o.hashCode === 'function') {\n\t      return o.hashCode();\n\t    }\n\t    return hashJSObj(o);\n\t  }\n\t\n\t  function cachedHashString(string) {\n\t    var hash = stringHashCache[string];\n\t    if (hash === undefined) {\n\t      hash = hashString(string);\n\t      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n\t        STRING_HASH_CACHE_SIZE = 0;\n\t        stringHashCache = {};\n\t      }\n\t      STRING_HASH_CACHE_SIZE++;\n\t      stringHashCache[string] = hash;\n\t    }\n\t    return hash;\n\t  }\n\t\n\t  // http://jsperf.com/hashing-strings\n\t  function hashString(string) {\n\t    // This is the hash from JVM\n\t    // The hash code for a string is computed as\n\t    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n\t    // where s[i] is the ith character of the string and n is the length of\n\t    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n\t    // (exclusive) by dropping high bits.\n\t    var hash = 0;\n\t    for (var ii = 0; ii < string.length; ii++) {\n\t      hash = 31 * hash + string.charCodeAt(ii) | 0;\n\t    }\n\t    return smi(hash);\n\t  }\n\t\n\t  function hashJSObj(obj) {\n\t    var hash = weakMap && weakMap.get(obj);\n\t    if (hash) return hash;\n\t\n\t    hash = obj[UID_HASH_KEY];\n\t    if (hash) return hash;\n\t\n\t    if (!canDefineProperty) {\n\t      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n\t      if (hash) return hash;\n\t\n\t      hash = getIENodeHash(obj);\n\t      if (hash) return hash;\n\t    }\n\t\n\t    if (Object.isExtensible && !Object.isExtensible(obj)) {\n\t      throw new Error('Non-extensible objects are not allowed as keys.');\n\t    }\n\t\n\t    hash = ++objHashUID;\n\t    if (objHashUID & 0x40000000) {\n\t      objHashUID = 0;\n\t    }\n\t\n\t    if (weakMap) {\n\t      weakMap.set(obj, hash);\n\t    } else if (canDefineProperty) {\n\t      Object.defineProperty(obj, UID_HASH_KEY, {\n\t        'enumerable': false,\n\t        'configurable': false,\n\t        'writable': false,\n\t        'value': hash\n\t      });\n\t    } else if (obj.propertyIsEnumerable &&\n\t               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n\t      // Since we can't define a non-enumerable property on the object\n\t      // we'll hijack one of the less-used non-enumerable properties to\n\t      // save our hash on it. Since this is a function it will not show up in\n\t      // `JSON.stringify` which is what we want.\n\t      obj.propertyIsEnumerable = function() {\n\t        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n\t      };\n\t      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n\t    } else if (obj.nodeType) {\n\t      // At this point we couldn't get the IE `uniqueID` to use as a hash\n\t      // and we couldn't use a non-enumerable property to exploit the\n\t      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n\t      // itself.\n\t      obj[UID_HASH_KEY] = hash;\n\t    } else {\n\t      throw new Error('Unable to set a non-enumerable property on object.');\n\t    }\n\t\n\t    return hash;\n\t  }\n\t\n\t  // True if Object.defineProperty works as expected. IE8 fails this test.\n\t  var canDefineProperty = (function() {\n\t    try {\n\t      Object.defineProperty({}, 'x', {});\n\t      return true;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  }());\n\t\n\t  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n\t  // and avoid memory leaks from the IE cloneNode bug.\n\t  function getIENodeHash(node) {\n\t    if (node && node.nodeType > 0) {\n\t      switch (node.nodeType) {\n\t        case 1: // Element\n\t          return node.uniqueID;\n\t        case 9: // Document\n\t          return node.documentElement && node.documentElement.uniqueID;\n\t      }\n\t    }\n\t  }\n\t\n\t  // If possible, use a WeakMap.\n\t  var weakMap = typeof WeakMap === 'function' && new WeakMap();\n\t\n\t  var objHashUID = 0;\n\t\n\t  var UID_HASH_KEY = '__immutablehash__';\n\t  if (typeof Symbol === 'function') {\n\t    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n\t  }\n\t\n\t  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n\t  var STRING_HASH_CACHE_MAX_SIZE = 255;\n\t  var STRING_HASH_CACHE_SIZE = 0;\n\t  var stringHashCache = {};\n\t\n\t  function invariant(condition, error) {\n\t    if (!condition) throw new Error(error);\n\t  }\n\t\n\t  function assertNotInfinite(size) {\n\t    invariant(\n\t      size !== Infinity,\n\t      'Cannot perform this action with an infinite size.'\n\t    );\n\t  }\n\t\n\t  createClass(ToKeyedSequence, KeyedSeq);\n\t    function ToKeyedSequence(indexed, useKeys) {\n\t      this._iter = indexed;\n\t      this._useKeys = useKeys;\n\t      this.size = indexed.size;\n\t    }\n\t\n\t    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n\t      return this._iter.get(key, notSetValue);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.has = function(key) {\n\t      return this._iter.has(key);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.valueSeq = function() {\n\t      return this._iter.valueSeq();\n\t    };\n\t\n\t    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n\t      var reversedSequence = reverseFactory(this, true);\n\t      if (!this._useKeys) {\n\t        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n\t      }\n\t      return reversedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n\t      var mappedSequence = mapFactory(this, mapper, context);\n\t      if (!this._useKeys) {\n\t        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n\t      }\n\t      return mappedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var ii;\n\t      return this._iter.__iterate(\n\t        this._useKeys ?\n\t          function(v, k)  {return fn(v, k, this$0)} :\n\t          ((ii = reverse ? resolveSize(this) : 0),\n\t            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n\t        reverse\n\t      );\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n\t      if (this._useKeys) {\n\t        return this._iter.__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var ii = reverse ? resolveSize(this) : 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n\t      });\n\t    };\n\t\n\t  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(ToIndexedSequence, IndexedSeq);\n\t    function ToIndexedSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToIndexedSequence.prototype.contains = function(value) {\n\t      return this._iter.contains(value);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, iterations++, step.value, step)\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(ToSetSequence, SetSeq);\n\t    function ToSetSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToSetSequence.prototype.has = function(key) {\n\t      return this._iter.contains(key);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, step.value, step.value, step);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(FromEntriesSequence, KeyedSeq);\n\t    function FromEntriesSequence(entries) {\n\t      this._iter = entries;\n\t      this.size = entries.size;\n\t    }\n\t\n\t    FromEntriesSequence.prototype.entrySeq = function() {\n\t      return this._iter.toSeq();\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(entry ) {\n\t        // Check if entry exists first so array access doesn't throw for holes\n\t        // in the parent iteration.\n\t        if (entry) {\n\t          validateEntry(entry);\n\t          return fn(entry[1], entry[0], this$0);\n\t        }\n\t      }, reverse);\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          // Check if entry exists first so array access doesn't throw for holes\n\t          // in the parent iteration.\n\t          if (entry) {\n\t            validateEntry(entry);\n\t            return type === ITERATE_ENTRIES ? step :\n\t              iteratorValue(type, entry[0], entry[1], step);\n\t          }\n\t        }\n\t      });\n\t    };\n\t\n\t\n\t  ToIndexedSequence.prototype.cacheResult =\n\t  ToKeyedSequence.prototype.cacheResult =\n\t  ToSetSequence.prototype.cacheResult =\n\t  FromEntriesSequence.prototype.cacheResult =\n\t    cacheResultThrough;\n\t\n\t\n\t  function flipFactory(iterable) {\n\t    var flipSequence = makeSequence(iterable);\n\t    flipSequence._iter = iterable;\n\t    flipSequence.size = iterable.size;\n\t    flipSequence.flip = function()  {return iterable};\n\t    flipSequence.reverse = function () {\n\t      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n\t      reversedSequence.flip = function()  {return iterable.reverse()};\n\t      return reversedSequence;\n\t    };\n\t    flipSequence.has = function(key ) {return iterable.contains(key)};\n\t    flipSequence.contains = function(key ) {return iterable.has(key)};\n\t    flipSequence.cacheResult = cacheResultThrough;\n\t    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n\t    }\n\t    flipSequence.__iteratorUncached = function(type, reverse) {\n\t      if (type === ITERATE_ENTRIES) {\n\t        var iterator = iterable.__iterator(type, reverse);\n\t        return new Iterator(function()  {\n\t          var step = iterator.next();\n\t          if (!step.done) {\n\t            var k = step.value[0];\n\t            step.value[0] = step.value[1];\n\t            step.value[1] = k;\n\t          }\n\t          return step;\n\t        });\n\t      }\n\t      return iterable.__iterator(\n\t        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n\t        reverse\n\t      );\n\t    }\n\t    return flipSequence;\n\t  }\n\t\n\t\n\t  function mapFactory(iterable, mapper, context) {\n\t    var mappedSequence = makeSequence(iterable);\n\t    mappedSequence.size = iterable.size;\n\t    mappedSequence.has = function(key ) {return iterable.has(key)};\n\t    mappedSequence.get = function(key, notSetValue)  {\n\t      var v = iterable.get(key, NOT_SET);\n\t      return v === NOT_SET ?\n\t        notSetValue :\n\t        mapper.call(context, v, key, iterable);\n\t    };\n\t    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(\n\t        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n\t        reverse\n\t      );\n\t    }\n\t    mappedSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var key = entry[0];\n\t        return iteratorValue(\n\t          type,\n\t          key,\n\t          mapper.call(context, entry[1], key, iterable),\n\t          step\n\t        );\n\t      });\n\t    }\n\t    return mappedSequence;\n\t  }\n\t\n\t\n\t  function reverseFactory(iterable, useKeys) {\n\t    var reversedSequence = makeSequence(iterable);\n\t    reversedSequence._iter = iterable;\n\t    reversedSequence.size = iterable.size;\n\t    reversedSequence.reverse = function()  {return iterable};\n\t    if (iterable.flip) {\n\t      reversedSequence.flip = function () {\n\t        var flipSequence = flipFactory(iterable);\n\t        flipSequence.reverse = function()  {return iterable.flip()};\n\t        return flipSequence;\n\t      };\n\t    }\n\t    reversedSequence.get = function(key, notSetValue) \n\t      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n\t    reversedSequence.has = function(key )\n\t      {return iterable.has(useKeys ? key : -1 - key)};\n\t    reversedSequence.contains = function(value ) {return iterable.contains(value)};\n\t    reversedSequence.cacheResult = cacheResultThrough;\n\t    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n\t    };\n\t    reversedSequence.__iterator =\n\t      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n\t    return reversedSequence;\n\t  }\n\t\n\t\n\t  function filterFactory(iterable, predicate, context, useKeys) {\n\t    var filterSequence = makeSequence(iterable);\n\t    if (useKeys) {\n\t      filterSequence.has = function(key ) {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n\t      };\n\t      filterSequence.get = function(key, notSetValue)  {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n\t          v : notSetValue;\n\t      };\n\t    }\n\t    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t    filterSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          var key = entry[0];\n\t          var value = entry[1];\n\t          if (predicate.call(context, value, key, iterable)) {\n\t            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n\t          }\n\t        }\n\t      });\n\t    }\n\t    return filterSequence;\n\t  }\n\t\n\t\n\t  function countByFactory(iterable, grouper, context) {\n\t    var groups = Map().asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        0,\n\t        function(a ) {return a + 1}\n\t      );\n\t    });\n\t    return groups.asImmutable();\n\t  }\n\t\n\t\n\t  function groupByFactory(iterable, grouper, context) {\n\t    var isKeyedIter = isKeyed(iterable);\n\t    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n\t      );\n\t    });\n\t    var coerce = iterableClass(iterable);\n\t    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n\t  }\n\t\n\t\n\t  function sliceFactory(iterable, begin, end, useKeys) {\n\t    var originalSize = iterable.size;\n\t\n\t    if (wholeSlice(begin, end, originalSize)) {\n\t      return iterable;\n\t    }\n\t\n\t    var resolvedBegin = resolveBegin(begin, originalSize);\n\t    var resolvedEnd = resolveEnd(end, originalSize);\n\t\n\t    // begin or end will be NaN if they were provided as negative numbers and\n\t    // this iterable's size is unknown. In that case, cache first so there is\n\t    // a known size.\n\t    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n\t      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n\t    }\n\t\n\t    var sliceSize = resolvedEnd - resolvedBegin;\n\t    if (sliceSize < 0) {\n\t      sliceSize = 0;\n\t    }\n\t\n\t    var sliceSeq = makeSequence(iterable);\n\t\n\t    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\t\n\t    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n\t      sliceSeq.get = function (index, notSetValue) {\n\t        index = wrapIndex(this, index);\n\t        return index >= 0 && index < sliceSize ?\n\t          iterable.get(index + resolvedBegin, notSetValue) :\n\t          notSetValue;\n\t      }\n\t    }\n\t\n\t    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (sliceSize === 0) {\n\t        return 0;\n\t      }\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var skipped = 0;\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k)  {\n\t        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n\t                 iterations !== sliceSize;\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t\n\t    sliceSeq.__iteratorUncached = function(type, reverse) {\n\t      if (sliceSize && reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      // Don't bother instantiating parent iterator if taking 0.\n\t      var iterator = sliceSize && iterable.__iterator(type, reverse);\n\t      var skipped = 0;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (skipped++ !== resolvedBegin) {\n\t          iterator.next();\n\t        }\n\t        if (++iterations > sliceSize) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (useKeys || type === ITERATE_VALUES) {\n\t          return step;\n\t        } else if (type === ITERATE_KEYS) {\n\t          return iteratorValue(type, iterations - 1, undefined, step);\n\t        } else {\n\t          return iteratorValue(type, iterations - 1, step.value[1], step);\n\t        }\n\t      });\n\t    }\n\t\n\t    return sliceSeq;\n\t  }\n\t\n\t\n\t  function takeWhileFactory(iterable, predicate, context) {\n\t    var takeSequence = makeSequence(iterable);\n\t    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c) \n\t        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n\t      );\n\t      return iterations;\n\t    };\n\t    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterating = true;\n\t      return new Iterator(function()  {\n\t        if (!iterating) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var k = entry[0];\n\t        var v = entry[1];\n\t        if (!predicate.call(context, v, k, this$0)) {\n\t          iterating = false;\n\t          return iteratorDone();\n\t        }\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return takeSequence;\n\t  }\n\t\n\t\n\t  function skipWhileFactory(iterable, predicate, context, useKeys) {\n\t    var skipSequence = makeSequence(iterable);\n\t    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var skipping = true;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step, k, v;\n\t        do {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            if (useKeys || type === ITERATE_VALUES) {\n\t              return step;\n\t            } else if (type === ITERATE_KEYS) {\n\t              return iteratorValue(type, iterations++, undefined, step);\n\t            } else {\n\t              return iteratorValue(type, iterations++, step.value[1], step);\n\t            }\n\t          }\n\t          var entry = step.value;\n\t          k = entry[0];\n\t          v = entry[1];\n\t          skipping && (skipping = predicate.call(context, v, k, this$0));\n\t        } while (skipping);\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return skipSequence;\n\t  }\n\t\n\t\n\t  function concatFactory(iterable, values) {\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var iters = [iterable].concat(values).map(function(v ) {\n\t      if (!isIterable(v)) {\n\t        v = isKeyedIterable ?\n\t          keyedSeqFromValue(v) :\n\t          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n\t      } else if (isKeyedIterable) {\n\t        v = KeyedIterable(v);\n\t      }\n\t      return v;\n\t    }).filter(function(v ) {return v.size !== 0});\n\t\n\t    if (iters.length === 0) {\n\t      return iterable;\n\t    }\n\t\n\t    if (iters.length === 1) {\n\t      var singleton = iters[0];\n\t      if (singleton === iterable ||\n\t          isKeyedIterable && isKeyed(singleton) ||\n\t          isIndexed(iterable) && isIndexed(singleton)) {\n\t        return singleton;\n\t      }\n\t    }\n\t\n\t    var concatSeq = new ArraySeq(iters);\n\t    if (isKeyedIterable) {\n\t      concatSeq = concatSeq.toKeyedSeq();\n\t    } else if (!isIndexed(iterable)) {\n\t      concatSeq = concatSeq.toSetSeq();\n\t    }\n\t    concatSeq = concatSeq.flatten(true);\n\t    concatSeq.size = iters.reduce(\n\t      function(sum, seq)  {\n\t        if (sum !== undefined) {\n\t          var size = seq.size;\n\t          if (size !== undefined) {\n\t            return sum + size;\n\t          }\n\t        }\n\t      },\n\t      0\n\t    );\n\t    return concatSeq;\n\t  }\n\t\n\t\n\t  function flattenFactory(iterable, depth, useKeys) {\n\t    var flatSequence = makeSequence(iterable);\n\t    flatSequence.__iterateUncached = function(fn, reverse) {\n\t      var iterations = 0;\n\t      var stopped = false;\n\t      function flatDeep(iter, currentDepth) {var this$0 = this;\n\t        iter.__iterate(function(v, k)  {\n\t          if ((!depth || currentDepth < depth) && isIterable(v)) {\n\t            flatDeep(v, currentDepth + 1);\n\t          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n\t            stopped = true;\n\t          }\n\t          return !stopped;\n\t        }, reverse);\n\t      }\n\t      flatDeep(iterable, 0);\n\t      return iterations;\n\t    }\n\t    flatSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(type, reverse);\n\t      var stack = [];\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (iterator) {\n\t          var step = iterator.next();\n\t          if (step.done !== false) {\n\t            iterator = stack.pop();\n\t            continue;\n\t          }\n\t          var v = step.value;\n\t          if (type === ITERATE_ENTRIES) {\n\t            v = v[1];\n\t          }\n\t          if ((!depth || stack.length < depth) && isIterable(v)) {\n\t            stack.push(iterator);\n\t            iterator = v.__iterator(type, reverse);\n\t          } else {\n\t            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n\t          }\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    }\n\t    return flatSequence;\n\t  }\n\t\n\t\n\t  function flatMapFactory(iterable, mapper, context) {\n\t    var coerce = iterableClass(iterable);\n\t    return iterable.toSeq().map(\n\t      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n\t    ).flatten(true);\n\t  }\n\t\n\t\n\t  function interposeFactory(iterable, separator) {\n\t    var interposedSequence = makeSequence(iterable);\n\t    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n\t    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k) \n\t        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n\t        fn(v, iterations++, this$0) !== false},\n\t        reverse\n\t      );\n\t      return iterations;\n\t    };\n\t    interposedSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      var step;\n\t      return new Iterator(function()  {\n\t        if (!step || iterations % 2) {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t        }\n\t        return iterations % 2 ?\n\t          iteratorValue(type, iterations++, separator) :\n\t          iteratorValue(type, iterations++, step.value, step);\n\t      });\n\t    };\n\t    return interposedSequence;\n\t  }\n\t\n\t\n\t  function sortFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var index = 0;\n\t    var entries = iterable.toSeq().map(\n\t      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n\t    ).toArray();\n\t    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n\t      isKeyedIterable ?\n\t      function(v, i)  { entries[i].length = 2; } :\n\t      function(v, i)  { entries[i] = v[1]; }\n\t    );\n\t    return isKeyedIterable ? KeyedSeq(entries) :\n\t      isIndexed(iterable) ? IndexedSeq(entries) :\n\t      SetSeq(entries);\n\t  }\n\t\n\t\n\t  function maxFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    if (mapper) {\n\t      var entry = iterable.toSeq()\n\t        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n\t        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n\t      return entry && entry[0];\n\t    } else {\n\t      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n\t    }\n\t  }\n\t\n\t  function maxCompare(comparator, a, b) {\n\t    var comp = comparator(b, a);\n\t    // b is considered the new max if the comparator declares them equal, but\n\t    // they are not equal and b is in fact a nullish value.\n\t    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n\t  }\n\t\n\t\n\t  function zipWithFactory(keyIter, zipper, iters) {\n\t    var zipSequence = makeSequence(keyIter);\n\t    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n\t    // Note: this a generic base implementation of __iterate in terms of\n\t    // __iterator which may be more generically useful in the future.\n\t    zipSequence.__iterate = function(fn, reverse) {\n\t      /* generic:\n\t      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        iterations++;\n\t        if (fn(step.value[1], step.value[0], this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t      */\n\t      // indexed:\n\t      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        if (fn(step.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t    zipSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterators = iters.map(function(i )\n\t        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n\t      );\n\t      var iterations = 0;\n\t      var isDone = false;\n\t      return new Iterator(function()  {\n\t        var steps;\n\t        if (!isDone) {\n\t          steps = iterators.map(function(i ) {return i.next()});\n\t          isDone = steps.some(function(s ) {return s.done});\n\t        }\n\t        if (isDone) {\n\t          return iteratorDone();\n\t        }\n\t        return iteratorValue(\n\t          type,\n\t          iterations++,\n\t          zipper.apply(null, steps.map(function(s ) {return s.value}))\n\t        );\n\t      });\n\t    };\n\t    return zipSequence\n\t  }\n\t\n\t\n\t  // #pragma Helper Functions\n\t\n\t  function reify(iter, seq) {\n\t    return isSeq(iter) ? seq : iter.constructor(seq);\n\t  }\n\t\n\t  function validateEntry(entry) {\n\t    if (entry !== Object(entry)) {\n\t      throw new TypeError('Expected [K, V] tuple: ' + entry);\n\t    }\n\t  }\n\t\n\t  function resolveSize(iter) {\n\t    assertNotInfinite(iter.size);\n\t    return ensureSize(iter);\n\t  }\n\t\n\t  function iterableClass(iterable) {\n\t    return isKeyed(iterable) ? KeyedIterable :\n\t      isIndexed(iterable) ? IndexedIterable :\n\t      SetIterable;\n\t  }\n\t\n\t  function makeSequence(iterable) {\n\t    return Object.create(\n\t      (\n\t        isKeyed(iterable) ? KeyedSeq :\n\t        isIndexed(iterable) ? IndexedSeq :\n\t        SetSeq\n\t      ).prototype\n\t    );\n\t  }\n\t\n\t  function cacheResultThrough() {\n\t    if (this._iter.cacheResult) {\n\t      this._iter.cacheResult();\n\t      this.size = this._iter.size;\n\t      return this;\n\t    } else {\n\t      return Seq.prototype.cacheResult.call(this);\n\t    }\n\t  }\n\t\n\t  function defaultComparator(a, b) {\n\t    return a > b ? 1 : a < b ? -1 : 0;\n\t  }\n\t\n\t  function forceIterator(keyPath) {\n\t    var iter = getIterator(keyPath);\n\t    if (!iter) {\n\t      // Array might not be iterable in this environment, so we need a fallback\n\t      // to our wrapped type.\n\t      if (!isArrayLike(keyPath)) {\n\t        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n\t      }\n\t      iter = getIterator(Iterable(keyPath));\n\t    }\n\t    return iter;\n\t  }\n\t\n\t  createClass(Map, KeyedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Map(value) {\n\t      return value === null || value === undefined ? emptyMap() :\n\t        isMap(value) ? value :\n\t        emptyMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    Map.prototype.toString = function() {\n\t      return this.__toString('Map {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Map.prototype.get = function(k, notSetValue) {\n\t      return this._root ?\n\t        this._root.get(0, undefined, k, notSetValue) :\n\t        notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Map.prototype.set = function(k, v) {\n\t      return updateMap(this, k, v);\n\t    };\n\t\n\t    Map.prototype.setIn = function(keyPath, v) {\n\t      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n\t    };\n\t\n\t    Map.prototype.remove = function(k) {\n\t      return updateMap(this, k, NOT_SET);\n\t    };\n\t\n\t    Map.prototype.deleteIn = function(keyPath) {\n\t      return this.updateIn(keyPath, function()  {return NOT_SET});\n\t    };\n\t\n\t    Map.prototype.update = function(k, notSetValue, updater) {\n\t      return arguments.length === 1 ?\n\t        k(this) :\n\t        this.updateIn([k], notSetValue, updater);\n\t    };\n\t\n\t    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n\t      if (!updater) {\n\t        updater = notSetValue;\n\t        notSetValue = undefined;\n\t      }\n\t      var updatedValue = updateInDeepMap(\n\t        this,\n\t        forceIterator(keyPath),\n\t        notSetValue,\n\t        updater\n\t      );\n\t      return updatedValue === NOT_SET ? undefined : updatedValue;\n\t    };\n\t\n\t    Map.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._root = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyMap();\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Map.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, undefined, arguments);\n\t    };\n\t\n\t    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, merger, iters);\n\t    };\n\t\n\t    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(keyPath, emptyMap(), function(m ) {return m.merge.apply(m, iters)});\n\t    };\n\t\n\t    Map.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, deepMerger(undefined), arguments);\n\t    };\n\t\n\t    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, deepMerger(merger), iters);\n\t    };\n\t\n\t    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(keyPath, emptyMap(), function(m ) {return m.mergeDeep.apply(m, iters)});\n\t    };\n\t\n\t    Map.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator));\n\t    };\n\t\n\t    Map.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Map.prototype.withMutations = function(fn) {\n\t      var mutable = this.asMutable();\n\t      fn(mutable);\n\t      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n\t    };\n\t\n\t    Map.prototype.asMutable = function() {\n\t      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n\t    };\n\t\n\t    Map.prototype.asImmutable = function() {\n\t      return this.__ensureOwner();\n\t    };\n\t\n\t    Map.prototype.wasAltered = function() {\n\t      return this.__altered;\n\t    };\n\t\n\t    Map.prototype.__iterator = function(type, reverse) {\n\t      return new MapIterator(this, type, reverse);\n\t    };\n\t\n\t    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      this._root && this._root.iterate(function(entry ) {\n\t        iterations++;\n\t        return fn(entry[1], entry[0], this$0);\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t\n\t    Map.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeMap(this.size, this._root, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isMap(maybeMap) {\n\t    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n\t  }\n\t\n\t  Map.isMap = isMap;\n\t\n\t  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\t\n\t  var MapPrototype = Map.prototype;\n\t  MapPrototype[IS_MAP_SENTINEL] = true;\n\t  MapPrototype[DELETE] = MapPrototype.remove;\n\t  MapPrototype.removeIn = MapPrototype.deleteIn;\n\t\n\t\n\t  // #pragma Trie Nodes\n\t\n\t\n\t\n\t    function ArrayMapNode(ownerID, entries) {\n\t      this.ownerID = ownerID;\n\t      this.entries = entries;\n\t    }\n\t\n\t    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && entries.length === 1) {\n\t        return; // undefined\n\t      }\n\t\n\t      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n\t        return createNodes(ownerID, entries, key, value);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new ArrayMapNode(ownerID, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.bitmap = bitmap;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n\t      var bitmap = this.bitmap;\n\t      return (bitmap & bit) === 0 ? notSetValue :\n\t        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n\t    };\n\t\n\t    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var bit = 1 << keyHashFrag;\n\t      var bitmap = this.bitmap;\n\t      var exists = (bitmap & bit) !== 0;\n\t\n\t      if (!exists && value === NOT_SET) {\n\t        return this;\n\t      }\n\t\n\t      var idx = popCount(bitmap & (bit - 1));\n\t      var nodes = this.nodes;\n\t      var node = exists ? nodes[idx] : undefined;\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n\t        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n\t      }\n\t\n\t      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n\t        return nodes[idx ^ 1];\n\t      }\n\t\n\t      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n\t        return newNode;\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n\t      var newNodes = exists ? newNode ?\n\t        setIn(nodes, idx, newNode, isEditable) :\n\t        spliceOut(nodes, idx, isEditable) :\n\t        spliceIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.bitmap = newBitmap;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashArrayMapNode(ownerID, count, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.count = count;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var node = this.nodes[idx];\n\t      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n\t    };\n\t\n\t    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var removed = value === NOT_SET;\n\t      var nodes = this.nodes;\n\t      var node = nodes[idx];\n\t\n\t      if (removed && !node) {\n\t        return this;\n\t      }\n\t\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      var newCount = this.count;\n\t      if (!node) {\n\t        newCount++;\n\t      } else if (!newNode) {\n\t        newCount--;\n\t        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n\t          return packNodes(ownerID, nodes, newCount, idx);\n\t        }\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.count = newCount;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new HashArrayMapNode(ownerID, newCount, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashCollisionNode(ownerID, keyHash, entries) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entries = entries;\n\t    }\n\t\n\t    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t\n\t      var removed = value === NOT_SET;\n\t\n\t      if (keyHash !== this.keyHash) {\n\t        if (removed) {\n\t          return this;\n\t        }\n\t        SetRef(didAlter);\n\t        SetRef(didChangeSize);\n\t        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n\t      }\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && len === 2) {\n\t        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function ValueNode(ownerID, keyHash, entry) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entry = entry;\n\t    }\n\t\n\t    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n\t    };\n\t\n\t    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t      var keyMatch = is(key, this.entry[0]);\n\t      if (keyMatch ? value === this.entry[1] : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t\n\t      if (removed) {\n\t        SetRef(didChangeSize);\n\t        return; // undefined\n\t      }\n\t\n\t      if (keyMatch) {\n\t        if (ownerID && ownerID === this.ownerID) {\n\t          this.entry[1] = value;\n\t          return this;\n\t        }\n\t        return new ValueNode(ownerID, this.keyHash, [key, value]);\n\t      }\n\t\n\t      SetRef(didChangeSize);\n\t      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n\t    };\n\t\n\t\n\t\n\t  // #pragma Iterators\n\t\n\t  ArrayMapNode.prototype.iterate =\n\t  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n\t    var entries = this.entries;\n\t    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n\t      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  BitmapIndexedNode.prototype.iterate =\n\t  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n\t    var nodes = this.nodes;\n\t    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n\t      var node = nodes[reverse ? maxIndex - ii : ii];\n\t      if (node && node.iterate(fn, reverse) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  ValueNode.prototype.iterate = function (fn, reverse) {\n\t    return fn(this.entry);\n\t  }\n\t\n\t  createClass(MapIterator, Iterator);\n\t\n\t    function MapIterator(map, type, reverse) {\n\t      this._type = type;\n\t      this._reverse = reverse;\n\t      this._stack = map._root && mapIteratorFrame(map._root);\n\t    }\n\t\n\t    MapIterator.prototype.next = function() {\n\t      var type = this._type;\n\t      var stack = this._stack;\n\t      while (stack) {\n\t        var node = stack.node;\n\t        var index = stack.index++;\n\t        var maxIndex;\n\t        if (node.entry) {\n\t          if (index === 0) {\n\t            return mapIteratorValue(type, node.entry);\n\t          }\n\t        } else if (node.entries) {\n\t          maxIndex = node.entries.length - 1;\n\t          if (index <= maxIndex) {\n\t            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n\t          }\n\t        } else {\n\t          maxIndex = node.nodes.length - 1;\n\t          if (index <= maxIndex) {\n\t            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n\t            if (subNode) {\n\t              if (subNode.entry) {\n\t                return mapIteratorValue(type, subNode.entry);\n\t              }\n\t              stack = this._stack = mapIteratorFrame(subNode, stack);\n\t            }\n\t            continue;\n\t          }\n\t        }\n\t        stack = this._stack = this._stack.__prev;\n\t      }\n\t      return iteratorDone();\n\t    };\n\t\n\t\n\t  function mapIteratorValue(type, entry) {\n\t    return iteratorValue(type, entry[0], entry[1]);\n\t  }\n\t\n\t  function mapIteratorFrame(node, prev) {\n\t    return {\n\t      node: node,\n\t      index: 0,\n\t      __prev: prev\n\t    };\n\t  }\n\t\n\t  function makeMap(size, root, ownerID, hash) {\n\t    var map = Object.create(MapPrototype);\n\t    map.size = size;\n\t    map._root = root;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_MAP;\n\t  function emptyMap() {\n\t    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n\t  }\n\t\n\t  function updateMap(map, k, v) {\n\t    var newRoot;\n\t    var newSize;\n\t    if (!map._root) {\n\t      if (v === NOT_SET) {\n\t        return map;\n\t      }\n\t      newSize = 1;\n\t      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n\t    } else {\n\t      var didChangeSize = MakeRef(CHANGE_LENGTH);\n\t      var didAlter = MakeRef(DID_ALTER);\n\t      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n\t      if (!didAlter.value) {\n\t        return map;\n\t      }\n\t      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n\t    }\n\t    if (map.__ownerID) {\n\t      map.size = newSize;\n\t      map._root = newRoot;\n\t      map.__hash = undefined;\n\t      map.__altered = true;\n\t      return map;\n\t    }\n\t    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n\t  }\n\t\n\t  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t    if (!node) {\n\t      if (value === NOT_SET) {\n\t        return node;\n\t      }\n\t      SetRef(didAlter);\n\t      SetRef(didChangeSize);\n\t      return new ValueNode(ownerID, keyHash, [key, value]);\n\t    }\n\t    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n\t  }\n\t\n\t  function isLeafNode(node) {\n\t    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n\t  }\n\t\n\t  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n\t    if (node.keyHash === keyHash) {\n\t      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n\t    }\n\t\n\t    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n\t    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t\n\t    var newNode;\n\t    var nodes = idx1 === idx2 ?\n\t      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n\t      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\t\n\t    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n\t  }\n\t\n\t  function createNodes(ownerID, entries, key, value) {\n\t    if (!ownerID) {\n\t      ownerID = new OwnerID();\n\t    }\n\t    var node = new ValueNode(ownerID, hash(key), [key, value]);\n\t    for (var ii = 0; ii < entries.length; ii++) {\n\t      var entry = entries[ii];\n\t      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n\t    }\n\t    return node;\n\t  }\n\t\n\t  function packNodes(ownerID, nodes, count, excluding) {\n\t    var bitmap = 0;\n\t    var packedII = 0;\n\t    var packedNodes = new Array(count);\n\t    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n\t      var node = nodes[ii];\n\t      if (node !== undefined && ii !== excluding) {\n\t        bitmap |= bit;\n\t        packedNodes[packedII++] = node;\n\t      }\n\t    }\n\t    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n\t  }\n\t\n\t  function expandNodes(ownerID, nodes, bitmap, including, node) {\n\t    var count = 0;\n\t    var expandedNodes = new Array(SIZE);\n\t    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n\t      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n\t    }\n\t    expandedNodes[including] = node;\n\t    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n\t  }\n\t\n\t  function mergeIntoMapWith(map, merger, iterables) {\n\t    var iters = [];\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = KeyedIterable(value);\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    return mergeIntoCollectionWith(map, merger, iters);\n\t  }\n\t\n\t  function deepMerger(merger) {\n\t    return function(existing, value) \n\t      {return existing && existing.mergeDeepWith && isIterable(value) ?\n\t        existing.mergeDeepWith(merger, value) :\n\t        merger ? merger(existing, value) : value};\n\t  }\n\t\n\t  function mergeIntoCollectionWith(collection, merger, iters) {\n\t    iters = iters.filter(function(x ) {return x.size !== 0});\n\t    if (iters.length === 0) {\n\t      return collection;\n\t    }\n\t    if (collection.size === 0 && iters.length === 1) {\n\t      return collection.constructor(iters[0]);\n\t    }\n\t    return collection.withMutations(function(collection ) {\n\t      var mergeIntoMap = merger ?\n\t        function(value, key)  {\n\t          collection.update(key, NOT_SET, function(existing )\n\t            {return existing === NOT_SET ? value : merger(existing, value)}\n\t          );\n\t        } :\n\t        function(value, key)  {\n\t          collection.set(key, value);\n\t        }\n\t      for (var ii = 0; ii < iters.length; ii++) {\n\t        iters[ii].forEach(mergeIntoMap);\n\t      }\n\t    });\n\t  }\n\t\n\t  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n\t    var isNotSet = existing === NOT_SET;\n\t    var step = keyPathIter.next();\n\t    if (step.done) {\n\t      var existingValue = isNotSet ? notSetValue : existing;\n\t      var newValue = updater(existingValue);\n\t      return newValue === existingValue ? existing : newValue;\n\t    }\n\t    invariant(\n\t      isNotSet || (existing && existing.set),\n\t      'invalid keyPath'\n\t    );\n\t    var key = step.value;\n\t    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n\t    var nextUpdated = updateInDeepMap(\n\t      nextExisting,\n\t      keyPathIter,\n\t      notSetValue,\n\t      updater\n\t    );\n\t    return nextUpdated === nextExisting ? existing :\n\t      nextUpdated === NOT_SET ? existing.remove(key) :\n\t      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n\t  }\n\t\n\t  function popCount(x) {\n\t    x = x - ((x >> 1) & 0x55555555);\n\t    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n\t    x = (x + (x >> 4)) & 0x0f0f0f0f;\n\t    x = x + (x >> 8);\n\t    x = x + (x >> 16);\n\t    return x & 0x7f;\n\t  }\n\t\n\t  function setIn(array, idx, val, canEdit) {\n\t    var newArray = canEdit ? array : arrCopy(array);\n\t    newArray[idx] = val;\n\t    return newArray;\n\t  }\n\t\n\t  function spliceIn(array, idx, val, canEdit) {\n\t    var newLen = array.length + 1;\n\t    if (canEdit && idx + 1 === newLen) {\n\t      array[idx] = val;\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        newArray[ii] = val;\n\t        after = -1;\n\t      } else {\n\t        newArray[ii] = array[ii + after];\n\t      }\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  function spliceOut(array, idx, canEdit) {\n\t    var newLen = array.length - 1;\n\t    if (canEdit && idx === newLen) {\n\t      array.pop();\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        after = 1;\n\t      }\n\t      newArray[ii] = array[ii + after];\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n\t  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n\t  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\t\n\t  createClass(List, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function List(value) {\n\t      var empty = emptyList();\n\t      if (value === null || value === undefined) {\n\t        return empty;\n\t      }\n\t      if (isList(value)) {\n\t        return value;\n\t      }\n\t      var iter = IndexedIterable(value);\n\t      var size = iter.size;\n\t      if (size === 0) {\n\t        return empty;\n\t      }\n\t      assertNotInfinite(size);\n\t      if (size > 0 && size < SIZE) {\n\t        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n\t      }\n\t      return empty.withMutations(function(list ) {\n\t        list.setSize(size);\n\t        iter.forEach(function(v, i)  {return list.set(i, v)});\n\t      });\n\t    }\n\t\n\t    List.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    List.prototype.toString = function() {\n\t      return this.__toString('List [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    List.prototype.get = function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      if (index < 0 || index >= this.size) {\n\t        return notSetValue;\n\t      }\n\t      index += this._origin;\n\t      var node = listNodeFor(this, index);\n\t      return node && node.array[index & MASK];\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    List.prototype.set = function(index, value) {\n\t      return updateList(this, index, value);\n\t    };\n\t\n\t    List.prototype.remove = function(index) {\n\t      return !this.has(index) ? this :\n\t        index === 0 ? this.shift() :\n\t        index === this.size - 1 ? this.pop() :\n\t        this.splice(index, 1);\n\t    };\n\t\n\t    List.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = this._origin = this._capacity = 0;\n\t        this._level = SHIFT;\n\t        this._root = this._tail = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyList();\n\t    };\n\t\n\t    List.prototype.push = function(/*...values*/) {\n\t      var values = arguments;\n\t      var oldSize = this.size;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, 0, oldSize + values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(oldSize + ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.pop = function() {\n\t      return setListBounds(this, 0, -1);\n\t    };\n\t\n\t    List.prototype.unshift = function(/*...values*/) {\n\t      var values = arguments;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, -values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.shift = function() {\n\t      return setListBounds(this, 1);\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    List.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, undefined, arguments);\n\t    };\n\t\n\t    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, merger, iters);\n\t    };\n\t\n\t    List.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, deepMerger(undefined), arguments);\n\t    };\n\t\n\t    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, deepMerger(merger), iters);\n\t    };\n\t\n\t    List.prototype.setSize = function(size) {\n\t      return setListBounds(this, 0, size);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    List.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      if (wholeSlice(begin, end, size)) {\n\t        return this;\n\t      }\n\t      return setListBounds(\n\t        this,\n\t        resolveBegin(begin, size),\n\t        resolveEnd(end, size)\n\t      );\n\t    };\n\t\n\t    List.prototype.__iterator = function(type, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      return new Iterator(function()  {\n\t        var value = values();\n\t        return value === DONE ?\n\t          iteratorDone() :\n\t          iteratorValue(type, index++, value);\n\t      });\n\t    };\n\t\n\t    List.prototype.__iterate = function(fn, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      var value;\n\t      while ((value = values()) !== DONE) {\n\t        if (fn(value, index++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return index;\n\t    };\n\t\n\t    List.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        return this;\n\t      }\n\t      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isList(maybeList) {\n\t    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n\t  }\n\t\n\t  List.isList = isList;\n\t\n\t  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\t\n\t  var ListPrototype = List.prototype;\n\t  ListPrototype[IS_LIST_SENTINEL] = true;\n\t  ListPrototype[DELETE] = ListPrototype.remove;\n\t  ListPrototype.setIn = MapPrototype.setIn;\n\t  ListPrototype.deleteIn =\n\t  ListPrototype.removeIn = MapPrototype.removeIn;\n\t  ListPrototype.update = MapPrototype.update;\n\t  ListPrototype.updateIn = MapPrototype.updateIn;\n\t  ListPrototype.mergeIn = MapPrototype.mergeIn;\n\t  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  ListPrototype.withMutations = MapPrototype.withMutations;\n\t  ListPrototype.asMutable = MapPrototype.asMutable;\n\t  ListPrototype.asImmutable = MapPrototype.asImmutable;\n\t  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t\n\t    function VNode(array, ownerID) {\n\t      this.array = array;\n\t      this.ownerID = ownerID;\n\t    }\n\t\n\t    // TODO: seems like these methods are very similar\n\t\n\t    VNode.prototype.removeBefore = function(ownerID, level, index) {\n\t      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var originIndex = (index >>> level) & MASK;\n\t      if (originIndex >= this.array.length) {\n\t        return new VNode([], ownerID);\n\t      }\n\t      var removingFirst = originIndex === 0;\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[originIndex];\n\t        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && removingFirst) {\n\t          return this;\n\t        }\n\t      }\n\t      if (removingFirst && !newChild) {\n\t        return this;\n\t      }\n\t      var editable = editableVNode(this, ownerID);\n\t      if (!removingFirst) {\n\t        for (var ii = 0; ii < originIndex; ii++) {\n\t          editable.array[ii] = undefined;\n\t        }\n\t      }\n\t      if (newChild) {\n\t        editable.array[originIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t    VNode.prototype.removeAfter = function(ownerID, level, index) {\n\t      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var sizeIndex = ((index - 1) >>> level) & MASK;\n\t      if (sizeIndex >= this.array.length) {\n\t        return this;\n\t      }\n\t      var removingLast = sizeIndex === this.array.length - 1;\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[sizeIndex];\n\t        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && removingLast) {\n\t          return this;\n\t        }\n\t      }\n\t      if (removingLast && !newChild) {\n\t        return this;\n\t      }\n\t      var editable = editableVNode(this, ownerID);\n\t      if (!removingLast) {\n\t        editable.array.pop();\n\t      }\n\t      if (newChild) {\n\t        editable.array[sizeIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t\n\t\n\t  var DONE = {};\n\t\n\t  function iterateList(list, reverse) {\n\t    var left = list._origin;\n\t    var right = list._capacity;\n\t    var tailPos = getTailOffset(right);\n\t    var tail = list._tail;\n\t\n\t    return iterateNodeOrLeaf(list._root, list._level, 0);\n\t\n\t    function iterateNodeOrLeaf(node, level, offset) {\n\t      return level === 0 ?\n\t        iterateLeaf(node, offset) :\n\t        iterateNode(node, level, offset);\n\t    }\n\t\n\t    function iterateLeaf(node, offset) {\n\t      var array = offset === tailPos ? tail && tail.array : node && node.array;\n\t      var from = offset > left ? 0 : left - offset;\n\t      var to = right - offset;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        if (from === to) {\n\t          return DONE;\n\t        }\n\t        var idx = reverse ? --to : from++;\n\t        return array && array[idx];\n\t      };\n\t    }\n\t\n\t    function iterateNode(node, level, offset) {\n\t      var values;\n\t      var array = node && node.array;\n\t      var from = offset > left ? 0 : (left - offset) >> level;\n\t      var to = ((right - offset) >> level) + 1;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        do {\n\t          if (values) {\n\t            var value = values();\n\t            if (value !== DONE) {\n\t              return value;\n\t            }\n\t            values = null;\n\t          }\n\t          if (from === to) {\n\t            return DONE;\n\t          }\n\t          var idx = reverse ? --to : from++;\n\t          values = iterateNodeOrLeaf(\n\t            array && array[idx], level - SHIFT, offset + (idx << level)\n\t          );\n\t        } while (true);\n\t      };\n\t    }\n\t  }\n\t\n\t  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n\t    var list = Object.create(ListPrototype);\n\t    list.size = capacity - origin;\n\t    list._origin = origin;\n\t    list._capacity = capacity;\n\t    list._level = level;\n\t    list._root = root;\n\t    list._tail = tail;\n\t    list.__ownerID = ownerID;\n\t    list.__hash = hash;\n\t    list.__altered = false;\n\t    return list;\n\t  }\n\t\n\t  var EMPTY_LIST;\n\t  function emptyList() {\n\t    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n\t  }\n\t\n\t  function updateList(list, index, value) {\n\t    index = wrapIndex(list, index);\n\t\n\t    if (index >= list.size || index < 0) {\n\t      return list.withMutations(function(list ) {\n\t        index < 0 ?\n\t          setListBounds(list, index).set(0, value) :\n\t          setListBounds(list, 0, index + 1).set(index, value)\n\t      });\n\t    }\n\t\n\t    index += list._origin;\n\t\n\t    var newTail = list._tail;\n\t    var newRoot = list._root;\n\t    var didAlter = MakeRef(DID_ALTER);\n\t    if (index >= getTailOffset(list._capacity)) {\n\t      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n\t    } else {\n\t      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n\t    }\n\t\n\t    if (!didAlter.value) {\n\t      return list;\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n\t  }\n\t\n\t  function updateVNode(node, ownerID, level, index, value, didAlter) {\n\t    var idx = (index >>> level) & MASK;\n\t    var nodeHas = node && idx < node.array.length;\n\t    if (!nodeHas && value === undefined) {\n\t      return node;\n\t    }\n\t\n\t    var newNode;\n\t\n\t    if (level > 0) {\n\t      var lowerNode = node && node.array[idx];\n\t      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n\t      if (newLowerNode === lowerNode) {\n\t        return node;\n\t      }\n\t      newNode = editableVNode(node, ownerID);\n\t      newNode.array[idx] = newLowerNode;\n\t      return newNode;\n\t    }\n\t\n\t    if (nodeHas && node.array[idx] === value) {\n\t      return node;\n\t    }\n\t\n\t    SetRef(didAlter);\n\t\n\t    newNode = editableVNode(node, ownerID);\n\t    if (value === undefined && idx === newNode.array.length - 1) {\n\t      newNode.array.pop();\n\t    } else {\n\t      newNode.array[idx] = value;\n\t    }\n\t    return newNode;\n\t  }\n\t\n\t  function editableVNode(node, ownerID) {\n\t    if (ownerID && node && ownerID === node.ownerID) {\n\t      return node;\n\t    }\n\t    return new VNode(node ? node.array.slice() : [], ownerID);\n\t  }\n\t\n\t  function listNodeFor(list, rawIndex) {\n\t    if (rawIndex >= getTailOffset(list._capacity)) {\n\t      return list._tail;\n\t    }\n\t    if (rawIndex < 1 << (list._level + SHIFT)) {\n\t      var node = list._root;\n\t      var level = list._level;\n\t      while (node && level > 0) {\n\t        node = node.array[(rawIndex >>> level) & MASK];\n\t        level -= SHIFT;\n\t      }\n\t      return node;\n\t    }\n\t  }\n\t\n\t  function setListBounds(list, begin, end) {\n\t    var owner = list.__ownerID || new OwnerID();\n\t    var oldOrigin = list._origin;\n\t    var oldCapacity = list._capacity;\n\t    var newOrigin = oldOrigin + begin;\n\t    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n\t    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n\t      return list;\n\t    }\n\t\n\t    // If it's going to end after it starts, it's empty.\n\t    if (newOrigin >= newCapacity) {\n\t      return list.clear();\n\t    }\n\t\n\t    var newLevel = list._level;\n\t    var newRoot = list._root;\n\t\n\t    // New origin might require creating a higher root.\n\t    var offsetShift = 0;\n\t    while (newOrigin + offsetShift < 0) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t      offsetShift += 1 << newLevel;\n\t    }\n\t    if (offsetShift) {\n\t      newOrigin += offsetShift;\n\t      oldOrigin += offsetShift;\n\t      newCapacity += offsetShift;\n\t      oldCapacity += offsetShift;\n\t    }\n\t\n\t    var oldTailOffset = getTailOffset(oldCapacity);\n\t    var newTailOffset = getTailOffset(newCapacity);\n\t\n\t    // New size might require creating a higher root.\n\t    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t    }\n\t\n\t    // Locate or create the new tail.\n\t    var oldTail = list._tail;\n\t    var newTail = newTailOffset < oldTailOffset ?\n\t      listNodeFor(list, newCapacity - 1) :\n\t      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\t\n\t    // Merge Tail into tree.\n\t    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n\t      newRoot = editableVNode(newRoot, owner);\n\t      var node = newRoot;\n\t      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n\t        var idx = (oldTailOffset >>> level) & MASK;\n\t        node = node.array[idx] = editableVNode(node.array[idx], owner);\n\t      }\n\t      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n\t    }\n\t\n\t    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n\t    if (newCapacity < oldCapacity) {\n\t      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n\t    }\n\t\n\t    // If the new origin is within the tail, then we do not need a root.\n\t    if (newOrigin >= newTailOffset) {\n\t      newOrigin -= newTailOffset;\n\t      newCapacity -= newTailOffset;\n\t      newLevel = SHIFT;\n\t      newRoot = null;\n\t      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\t\n\t    // Otherwise, if the root has been trimmed, garbage collect.\n\t    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n\t      offsetShift = 0;\n\t\n\t      // Identify the new top root node of the subtree of the old root.\n\t      while (newRoot) {\n\t        var beginIndex = (newOrigin >>> newLevel) & MASK;\n\t        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n\t          break;\n\t        }\n\t        if (beginIndex) {\n\t          offsetShift += (1 << newLevel) * beginIndex;\n\t        }\n\t        newLevel -= SHIFT;\n\t        newRoot = newRoot.array[beginIndex];\n\t      }\n\t\n\t      // Trim the new sides of the new root.\n\t      if (newRoot && newOrigin > oldOrigin) {\n\t        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n\t      }\n\t      if (newRoot && newTailOffset < oldTailOffset) {\n\t        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n\t      }\n\t      if (offsetShift) {\n\t        newOrigin -= offsetShift;\n\t        newCapacity -= offsetShift;\n\t      }\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list.size = newCapacity - newOrigin;\n\t      list._origin = newOrigin;\n\t      list._capacity = newCapacity;\n\t      list._level = newLevel;\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n\t  }\n\t\n\t  function mergeIntoListWith(list, merger, iterables) {\n\t    var iters = [];\n\t    var maxSize = 0;\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = IndexedIterable(value);\n\t      if (iter.size > maxSize) {\n\t        maxSize = iter.size;\n\t      }\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    if (maxSize > list.size) {\n\t      list = list.setSize(maxSize);\n\t    }\n\t    return mergeIntoCollectionWith(list, merger, iters);\n\t  }\n\t\n\t  function getTailOffset(size) {\n\t    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n\t  }\n\t\n\t  createClass(OrderedMap, Map);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedMap(value) {\n\t      return value === null || value === undefined ? emptyOrderedMap() :\n\t        isOrderedMap(value) ? value :\n\t        emptyOrderedMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    OrderedMap.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedMap.prototype.toString = function() {\n\t      return this.__toString('OrderedMap {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    OrderedMap.prototype.get = function(k, notSetValue) {\n\t      var index = this._map.get(k);\n\t      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    OrderedMap.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._map.clear();\n\t        this._list.clear();\n\t        return this;\n\t      }\n\t      return emptyOrderedMap();\n\t    };\n\t\n\t    OrderedMap.prototype.set = function(k, v) {\n\t      return updateOrderedMap(this, k, v);\n\t    };\n\t\n\t    OrderedMap.prototype.remove = function(k) {\n\t      return updateOrderedMap(this, k, NOT_SET);\n\t    };\n\t\n\t    OrderedMap.prototype.wasAltered = function() {\n\t      return this._map.wasAltered() || this._list.wasAltered();\n\t    };\n\t\n\t    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._list.__iterate(\n\t        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n\t        reverse\n\t      );\n\t    };\n\t\n\t    OrderedMap.prototype.__iterator = function(type, reverse) {\n\t      return this._list.fromEntrySeq().__iterator(type, reverse);\n\t    };\n\t\n\t    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      var newList = this._list.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        this._list = newList;\n\t        return this;\n\t      }\n\t      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isOrderedMap(maybeOrderedMap) {\n\t    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n\t  }\n\t\n\t  OrderedMap.isOrderedMap = isOrderedMap;\n\t\n\t  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n\t  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\t\n\t\n\t\n\t  function makeOrderedMap(map, list, ownerID, hash) {\n\t    var omap = Object.create(OrderedMap.prototype);\n\t    omap.size = map ? map.size : 0;\n\t    omap._map = map;\n\t    omap._list = list;\n\t    omap.__ownerID = ownerID;\n\t    omap.__hash = hash;\n\t    return omap;\n\t  }\n\t\n\t  var EMPTY_ORDERED_MAP;\n\t  function emptyOrderedMap() {\n\t    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n\t  }\n\t\n\t  function updateOrderedMap(omap, k, v) {\n\t    var map = omap._map;\n\t    var list = omap._list;\n\t    var i = map.get(k);\n\t    var has = i !== undefined;\n\t    var newMap;\n\t    var newList;\n\t    if (v === NOT_SET) { // removed\n\t      if (!has) {\n\t        return omap;\n\t      }\n\t      if (list.size >= SIZE && list.size >= map.size * 2) {\n\t        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n\t        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n\t        if (omap.__ownerID) {\n\t          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n\t        }\n\t      } else {\n\t        newMap = map.remove(k);\n\t        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n\t      }\n\t    } else {\n\t      if (has) {\n\t        if (v === list.get(i)[1]) {\n\t          return omap;\n\t        }\n\t        newMap = map;\n\t        newList = list.set(i, [k, v]);\n\t      } else {\n\t        newMap = map.set(k, list.size);\n\t        newList = list.set(list.size, [k, v]);\n\t      }\n\t    }\n\t    if (omap.__ownerID) {\n\t      omap.size = newMap.size;\n\t      omap._map = newMap;\n\t      omap._list = newList;\n\t      omap.__hash = undefined;\n\t      return omap;\n\t    }\n\t    return makeOrderedMap(newMap, newList);\n\t  }\n\t\n\t  createClass(Stack, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Stack(value) {\n\t      return value === null || value === undefined ? emptyStack() :\n\t        isStack(value) ? value :\n\t        emptyStack().unshiftAll(value);\n\t    }\n\t\n\t    Stack.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Stack.prototype.toString = function() {\n\t      return this.__toString('Stack [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Stack.prototype.get = function(index, notSetValue) {\n\t      var head = this._head;\n\t      while (head && index--) {\n\t        head = head.next;\n\t      }\n\t      return head ? head.value : notSetValue;\n\t    };\n\t\n\t    Stack.prototype.peek = function() {\n\t      return this._head && this._head.value;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Stack.prototype.push = function(/*...values*/) {\n\t      if (arguments.length === 0) {\n\t        return this;\n\t      }\n\t      var newSize = this.size + arguments.length;\n\t      var head = this._head;\n\t      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n\t        head = {\n\t          value: arguments[ii],\n\t          next: head\n\t        };\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pushAll = function(iter) {\n\t      iter = IndexedIterable(iter);\n\t      if (iter.size === 0) {\n\t        return this;\n\t      }\n\t      assertNotInfinite(iter.size);\n\t      var newSize = this.size;\n\t      var head = this._head;\n\t      iter.reverse().forEach(function(value ) {\n\t        newSize++;\n\t        head = {\n\t          value: value,\n\t          next: head\n\t        };\n\t      });\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pop = function() {\n\t      return this.slice(1);\n\t    };\n\t\n\t    Stack.prototype.unshift = function(/*...values*/) {\n\t      return this.push.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.unshiftAll = function(iter) {\n\t      return this.pushAll(iter);\n\t    };\n\t\n\t    Stack.prototype.shift = function() {\n\t      return this.pop.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._head = undefined;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyStack();\n\t    };\n\t\n\t    Stack.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      var resolvedBegin = resolveBegin(begin, this.size);\n\t      var resolvedEnd = resolveEnd(end, this.size);\n\t      if (resolvedEnd !== this.size) {\n\t        // super.slice(begin, end);\n\t        return IndexedCollection.prototype.slice.call(this, begin, end);\n\t      }\n\t      var newSize = this.size - resolvedBegin;\n\t      var head = this._head;\n\t      while (resolvedBegin--) {\n\t        head = head.next;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Stack.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeStack(this.size, this._head, ownerID, this.__hash);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    Stack.prototype.__iterate = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.toSeq().cacheResult.__iterate(fn, reverse);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      while (node) {\n\t        if (fn(node.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t        node = node.next;\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    Stack.prototype.__iterator = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.toSeq().cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      return new Iterator(function()  {\n\t        if (node) {\n\t          var value = node.value;\n\t          node = node.next;\n\t          return iteratorValue(type, iterations++, value);\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    };\n\t\n\t\n\t  function isStack(maybeStack) {\n\t    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n\t  }\n\t\n\t  Stack.isStack = isStack;\n\t\n\t  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\t\n\t  var StackPrototype = Stack.prototype;\n\t  StackPrototype[IS_STACK_SENTINEL] = true;\n\t  StackPrototype.withMutations = MapPrototype.withMutations;\n\t  StackPrototype.asMutable = MapPrototype.asMutable;\n\t  StackPrototype.asImmutable = MapPrototype.asImmutable;\n\t  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t  function makeStack(size, head, ownerID, hash) {\n\t    var map = Object.create(StackPrototype);\n\t    map.size = size;\n\t    map._head = head;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_STACK;\n\t  function emptyStack() {\n\t    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n\t  }\n\t\n\t  createClass(Set, SetCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Set(value) {\n\t      return value === null || value === undefined ? emptySet() :\n\t        isSet(value) ? value :\n\t        emptySet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    Set.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Set.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    Set.prototype.toString = function() {\n\t      return this.__toString('Set {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Set.prototype.has = function(value) {\n\t      return this._map.has(value);\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Set.prototype.add = function(value) {\n\t      return updateSet(this, this._map.set(value, true));\n\t    };\n\t\n\t    Set.prototype.remove = function(value) {\n\t      return updateSet(this, this._map.remove(value));\n\t    };\n\t\n\t    Set.prototype.clear = function() {\n\t      return updateSet(this, this._map.clear());\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n\t      iters = iters.filter(function(x ) {return x.size !== 0});\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      if (this.size === 0 && iters.length === 1) {\n\t        return this.constructor(iters[0]);\n\t      }\n\t      return this.withMutations(function(set ) {\n\t        for (var ii = 0; ii < iters.length; ii++) {\n\t          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n\t        }\n\t      });\n\t    };\n\t\n\t    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (!iters.every(function(iter ) {return iter.contains(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (iters.some(function(iter ) {return iter.contains(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.merge = function() {\n\t      return this.union.apply(this, arguments);\n\t    };\n\t\n\t    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.union.apply(this, iters);\n\t    };\n\t\n\t    Set.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator));\n\t    };\n\t\n\t    Set.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    Set.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n\t    };\n\t\n\t    Set.prototype.__iterator = function(type, reverse) {\n\t      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n\t    };\n\t\n\t    Set.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return this.__make(newMap, ownerID);\n\t    };\n\t\n\t\n\t  function isSet(maybeSet) {\n\t    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n\t  }\n\t\n\t  Set.isSet = isSet;\n\t\n\t  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\t\n\t  var SetPrototype = Set.prototype;\n\t  SetPrototype[IS_SET_SENTINEL] = true;\n\t  SetPrototype[DELETE] = SetPrototype.remove;\n\t  SetPrototype.mergeDeep = SetPrototype.merge;\n\t  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n\t  SetPrototype.withMutations = MapPrototype.withMutations;\n\t  SetPrototype.asMutable = MapPrototype.asMutable;\n\t  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t  SetPrototype.__empty = emptySet;\n\t  SetPrototype.__make = makeSet;\n\t\n\t  function updateSet(set, newMap) {\n\t    if (set.__ownerID) {\n\t      set.size = newMap.size;\n\t      set._map = newMap;\n\t      return set;\n\t    }\n\t    return newMap === set._map ? set :\n\t      newMap.size === 0 ? set.__empty() :\n\t      set.__make(newMap);\n\t  }\n\t\n\t  function makeSet(map, ownerID) {\n\t    var set = Object.create(SetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_SET;\n\t  function emptySet() {\n\t    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n\t  }\n\t\n\t  createClass(OrderedSet, Set);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedSet(value) {\n\t      return value === null || value === undefined ? emptyOrderedSet() :\n\t        isOrderedSet(value) ? value :\n\t        emptyOrderedSet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    OrderedSet.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedSet.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    OrderedSet.prototype.toString = function() {\n\t      return this.__toString('OrderedSet {', '}');\n\t    };\n\t\n\t\n\t  function isOrderedSet(maybeOrderedSet) {\n\t    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n\t  }\n\t\n\t  OrderedSet.isOrderedSet = isOrderedSet;\n\t\n\t  var OrderedSetPrototype = OrderedSet.prototype;\n\t  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t  OrderedSetPrototype.__empty = emptyOrderedSet;\n\t  OrderedSetPrototype.__make = makeOrderedSet;\n\t\n\t  function makeOrderedSet(map, ownerID) {\n\t    var set = Object.create(OrderedSetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_ORDERED_SET;\n\t  function emptyOrderedSet() {\n\t    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n\t  }\n\t\n\t  createClass(Record, KeyedCollection);\n\t\n\t    function Record(defaultValues, name) {\n\t      var RecordType = function Record(values) {\n\t        if (!(this instanceof RecordType)) {\n\t          return new RecordType(values);\n\t        }\n\t        this._map = Map(values);\n\t      };\n\t\n\t      var keys = Object.keys(defaultValues);\n\t\n\t      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n\t      RecordTypePrototype.constructor = RecordType;\n\t      name && (RecordTypePrototype._name = name);\n\t      RecordTypePrototype._defaultValues = defaultValues;\n\t      RecordTypePrototype._keys = keys;\n\t      RecordTypePrototype.size = keys.length;\n\t\n\t      try {\n\t        keys.forEach(function(key ) {\n\t          Object.defineProperty(RecordType.prototype, key, {\n\t            get: function() {\n\t              return this.get(key);\n\t            },\n\t            set: function(value) {\n\t              invariant(this.__ownerID, 'Cannot set on an immutable record.');\n\t              this.set(key, value);\n\t            }\n\t          });\n\t        });\n\t      } catch (error) {\n\t        // Object.defineProperty failed. Probably IE8.\n\t      }\n\t\n\t      return RecordType;\n\t    }\n\t\n\t    Record.prototype.toString = function() {\n\t      return this.__toString(recordName(this) + ' {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Record.prototype.has = function(k) {\n\t      return this._defaultValues.hasOwnProperty(k);\n\t    };\n\t\n\t    Record.prototype.get = function(k, notSetValue) {\n\t      if (!this.has(k)) {\n\t        return notSetValue;\n\t      }\n\t      var defaultVal = this._defaultValues[k];\n\t      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Record.prototype.clear = function() {\n\t      if (this.__ownerID) {\n\t        this._map && this._map.clear();\n\t        return this;\n\t      }\n\t      var SuperRecord = Object.getPrototypeOf(this).constructor;\n\t      return SuperRecord._empty || (SuperRecord._empty = makeRecord(this, emptyMap()));\n\t    };\n\t\n\t    Record.prototype.set = function(k, v) {\n\t      if (!this.has(k)) {\n\t        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n\t      }\n\t      var newMap = this._map && this._map.set(k, v);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.remove = function(k) {\n\t      if (!this.has(k)) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.remove(k);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n\t    };\n\t\n\t    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n\t    };\n\t\n\t    Record.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap, ownerID);\n\t    };\n\t\n\t\n\t  var RecordPrototype = Record.prototype;\n\t  RecordPrototype[DELETE] = RecordPrototype.remove;\n\t  RecordPrototype.deleteIn =\n\t  RecordPrototype.removeIn = MapPrototype.removeIn;\n\t  RecordPrototype.merge = MapPrototype.merge;\n\t  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n\t  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n\t  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n\t  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n\t  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  RecordPrototype.setIn = MapPrototype.setIn;\n\t  RecordPrototype.update = MapPrototype.update;\n\t  RecordPrototype.updateIn = MapPrototype.updateIn;\n\t  RecordPrototype.withMutations = MapPrototype.withMutations;\n\t  RecordPrototype.asMutable = MapPrototype.asMutable;\n\t  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t\n\t  function makeRecord(likeRecord, map, ownerID) {\n\t    var record = Object.create(Object.getPrototypeOf(likeRecord));\n\t    record._map = map;\n\t    record.__ownerID = ownerID;\n\t    return record;\n\t  }\n\t\n\t  function recordName(record) {\n\t    return record._name || record.constructor.name;\n\t  }\n\t\n\t  function deepEqual(a, b) {\n\t    if (a === b) {\n\t      return true;\n\t    }\n\t\n\t    if (\n\t      !isIterable(b) ||\n\t      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n\t      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n\t      isKeyed(a) !== isKeyed(b) ||\n\t      isIndexed(a) !== isIndexed(b) ||\n\t      isOrdered(a) !== isOrdered(b)\n\t    ) {\n\t      return false;\n\t    }\n\t\n\t    if (a.size === 0 && b.size === 0) {\n\t      return true;\n\t    }\n\t\n\t    var notAssociative = !isAssociative(a);\n\t\n\t    if (isOrdered(a)) {\n\t      var entries = a.entries();\n\t      return b.every(function(v, k)  {\n\t        var entry = entries.next().value;\n\t        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n\t      }) && entries.next().done;\n\t    }\n\t\n\t    var flipped = false;\n\t\n\t    if (a.size === undefined) {\n\t      if (b.size === undefined) {\n\t        a.cacheResult();\n\t      } else {\n\t        flipped = true;\n\t        var _ = a;\n\t        a = b;\n\t        b = _;\n\t      }\n\t    }\n\t\n\t    var allEqual = true;\n\t    var bSize = b.__iterate(function(v, k)  {\n\t      if (notAssociative ? !a.has(v) :\n\t          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n\t        allEqual = false;\n\t        return false;\n\t      }\n\t    });\n\t\n\t    return allEqual && a.size === bSize;\n\t  }\n\t\n\t  createClass(Range, IndexedSeq);\n\t\n\t    function Range(start, end, step) {\n\t      if (!(this instanceof Range)) {\n\t        return new Range(start, end, step);\n\t      }\n\t      invariant(step !== 0, 'Cannot step a Range by 0');\n\t      start = start || 0;\n\t      if (end === undefined) {\n\t        end = Infinity;\n\t      }\n\t      step = step === undefined ? 1 : Math.abs(step);\n\t      if (end < start) {\n\t        step = -step;\n\t      }\n\t      this._start = start;\n\t      this._end = end;\n\t      this._step = step;\n\t      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n\t      if (this.size === 0) {\n\t        if (EMPTY_RANGE) {\n\t          return EMPTY_RANGE;\n\t        }\n\t        EMPTY_RANGE = this;\n\t      }\n\t    }\n\t\n\t    Range.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Range []';\n\t      }\n\t      return 'Range [ ' +\n\t        this._start + '...' + this._end +\n\t        (this._step > 1 ? ' by ' + this._step : '') +\n\t      ' ]';\n\t    };\n\t\n\t    Range.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ?\n\t        this._start + wrapIndex(this, index) * this._step :\n\t        notSetValue;\n\t    };\n\t\n\t    Range.prototype.contains = function(searchValue) {\n\t      var possibleIndex = (searchValue - this._start) / this._step;\n\t      return possibleIndex >= 0 &&\n\t        possibleIndex < this.size &&\n\t        possibleIndex === Math.floor(possibleIndex);\n\t    };\n\t\n\t    Range.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      begin = resolveBegin(begin, this.size);\n\t      end = resolveEnd(end, this.size);\n\t      if (end <= begin) {\n\t        return new Range(0, 0);\n\t      }\n\t      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n\t    };\n\t\n\t    Range.prototype.indexOf = function(searchValue) {\n\t      var offsetValue = searchValue - this._start;\n\t      if (offsetValue % this._step === 0) {\n\t        var index = offsetValue / this._step;\n\t        if (index >= 0 && index < this.size) {\n\t          return index\n\t        }\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Range.prototype.lastIndexOf = function(searchValue) {\n\t      return this.indexOf(searchValue);\n\t    };\n\t\n\t    Range.prototype.__iterate = function(fn, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t        value += reverse ? -step : step;\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Range.prototype.__iterator = function(type, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var v = value;\n\t        value += reverse ? -step : step;\n\t        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n\t      });\n\t    };\n\t\n\t    Range.prototype.equals = function(other) {\n\t      return other instanceof Range ?\n\t        this._start === other._start &&\n\t        this._end === other._end &&\n\t        this._step === other._step :\n\t        deepEqual(this, other);\n\t    };\n\t\n\t\n\t  var EMPTY_RANGE;\n\t\n\t  createClass(Repeat, IndexedSeq);\n\t\n\t    function Repeat(value, times) {\n\t      if (!(this instanceof Repeat)) {\n\t        return new Repeat(value, times);\n\t      }\n\t      this._value = value;\n\t      this.size = times === undefined ? Infinity : Math.max(0, times);\n\t      if (this.size === 0) {\n\t        if (EMPTY_REPEAT) {\n\t          return EMPTY_REPEAT;\n\t        }\n\t        EMPTY_REPEAT = this;\n\t      }\n\t    }\n\t\n\t    Repeat.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Repeat []';\n\t      }\n\t      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n\t    };\n\t\n\t    Repeat.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._value : notSetValue;\n\t    };\n\t\n\t    Repeat.prototype.contains = function(searchValue) {\n\t      return is(this._value, searchValue);\n\t    };\n\t\n\t    Repeat.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      return wholeSlice(begin, end, size) ? this :\n\t        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n\t    };\n\t\n\t    Repeat.prototype.reverse = function() {\n\t      return this;\n\t    };\n\t\n\t    Repeat.prototype.indexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return 0;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.lastIndexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return this.size;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.__iterate = function(fn, reverse) {\n\t      for (var ii = 0; ii < this.size; ii++) {\n\t        if (fn(this._value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n\t      );\n\t    };\n\t\n\t    Repeat.prototype.equals = function(other) {\n\t      return other instanceof Repeat ?\n\t        is(this._value, other._value) :\n\t        deepEqual(other);\n\t    };\n\t\n\t\n\t  var EMPTY_REPEAT;\n\t\n\t  /**\n\t   * Contributes additional methods to a constructor\n\t   */\n\t  function mixin(ctor, methods) {\n\t    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n\t    Object.keys(methods).forEach(keyCopier);\n\t    Object.getOwnPropertySymbols &&\n\t      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n\t    return ctor;\n\t  }\n\t\n\t  Iterable.Iterator = Iterator;\n\t\n\t  mixin(Iterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toArray: function() {\n\t      assertNotInfinite(this.size);\n\t      var array = new Array(this.size || 0);\n\t      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n\t      return array;\n\t    },\n\t\n\t    toIndexedSeq: function() {\n\t      return new ToIndexedSequence(this);\n\t    },\n\t\n\t    toJS: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toJSON: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, true);\n\t    },\n\t\n\t    toMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Map(this.toKeyedSeq());\n\t    },\n\t\n\t    toObject: function() {\n\t      assertNotInfinite(this.size);\n\t      var object = {};\n\t      this.__iterate(function(v, k)  { object[k] = v; });\n\t      return object;\n\t    },\n\t\n\t    toOrderedMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedMap(this.toKeyedSeq());\n\t    },\n\t\n\t    toOrderedSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Set(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSetSeq: function() {\n\t      return new ToSetSequence(this);\n\t    },\n\t\n\t    toSeq: function() {\n\t      return isIndexed(this) ? this.toIndexedSeq() :\n\t        isKeyed(this) ? this.toKeyedSeq() :\n\t        this.toSetSeq();\n\t    },\n\t\n\t    toStack: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Stack(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toList: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return List(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t\n\t    // ### Common JavaScript methods and properties\n\t\n\t    toString: function() {\n\t      return '[Iterable]';\n\t    },\n\t\n\t    __toString: function(head, tail) {\n\t      if (this.size === 0) {\n\t        return head + tail;\n\t      }\n\t      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    concat: function() {var values = SLICE$0.call(arguments, 0);\n\t      return reify(this, concatFactory(this, values));\n\t    },\n\t\n\t    contains: function(searchValue) {\n\t      return this.some(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    entries: function() {\n\t      return this.__iterator(ITERATE_ENTRIES);\n\t    },\n\t\n\t    every: function(predicate, context) {\n\t      assertNotInfinite(this.size);\n\t      var returnValue = true;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (!predicate.call(context, v, k, c)) {\n\t          returnValue = false;\n\t          return false;\n\t        }\n\t      });\n\t      return returnValue;\n\t    },\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, true));\n\t    },\n\t\n\t    find: function(predicate, context, notSetValue) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[1] : notSetValue;\n\t    },\n\t\n\t    findEntry: function(predicate, context) {\n\t      var found;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          found = [k, v];\n\t          return false;\n\t        }\n\t      });\n\t      return found;\n\t    },\n\t\n\t    findLastEntry: function(predicate, context) {\n\t      return this.toSeq().reverse().findEntry(predicate, context);\n\t    },\n\t\n\t    forEach: function(sideEffect, context) {\n\t      assertNotInfinite(this.size);\n\t      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n\t    },\n\t\n\t    join: function(separator) {\n\t      assertNotInfinite(this.size);\n\t      separator = separator !== undefined ? '' + separator : ',';\n\t      var joined = '';\n\t      var isFirst = true;\n\t      this.__iterate(function(v ) {\n\t        isFirst ? (isFirst = false) : (joined += separator);\n\t        joined += v !== null && v !== undefined ? v : '';\n\t      });\n\t      return joined;\n\t    },\n\t\n\t    keys: function() {\n\t      return this.__iterator(ITERATE_KEYS);\n\t    },\n\t\n\t    map: function(mapper, context) {\n\t      return reify(this, mapFactory(this, mapper, context));\n\t    },\n\t\n\t    reduce: function(reducer, initialReduction, context) {\n\t      assertNotInfinite(this.size);\n\t      var reduction;\n\t      var useFirst;\n\t      if (arguments.length < 2) {\n\t        useFirst = true;\n\t      } else {\n\t        reduction = initialReduction;\n\t      }\n\t      this.__iterate(function(v, k, c)  {\n\t        if (useFirst) {\n\t          useFirst = false;\n\t          reduction = v;\n\t        } else {\n\t          reduction = reducer.call(context, reduction, v, k, c);\n\t        }\n\t      });\n\t      return reduction;\n\t    },\n\t\n\t    reduceRight: function(reducer, initialReduction, context) {\n\t      var reversed = this.toKeyedSeq().reverse();\n\t      return reversed.reduce.apply(reversed, arguments);\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, true));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, true));\n\t    },\n\t\n\t    some: function(predicate, context) {\n\t      return !this.every(not(predicate), context);\n\t    },\n\t\n\t    sort: function(comparator) {\n\t      return reify(this, sortFactory(this, comparator));\n\t    },\n\t\n\t    values: function() {\n\t      return this.__iterator(ITERATE_VALUES);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    butLast: function() {\n\t      return this.slice(0, -1);\n\t    },\n\t\n\t    isEmpty: function() {\n\t      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n\t    },\n\t\n\t    count: function(predicate, context) {\n\t      return ensureSize(\n\t        predicate ? this.toSeq().filter(predicate, context) : this\n\t      );\n\t    },\n\t\n\t    countBy: function(grouper, context) {\n\t      return countByFactory(this, grouper, context);\n\t    },\n\t\n\t    equals: function(other) {\n\t      return deepEqual(this, other);\n\t    },\n\t\n\t    entrySeq: function() {\n\t      var iterable = this;\n\t      if (iterable._cache) {\n\t        // We cache as an entries array, so we can just return the cache!\n\t        return new ArraySeq(iterable._cache);\n\t      }\n\t      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n\t      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n\t      return entriesSequence;\n\t    },\n\t\n\t    filterNot: function(predicate, context) {\n\t      return this.filter(not(predicate), context);\n\t    },\n\t\n\t    findLast: function(predicate, context, notSetValue) {\n\t      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n\t    },\n\t\n\t    first: function() {\n\t      return this.find(returnTrue);\n\t    },\n\t\n\t    flatMap: function(mapper, context) {\n\t      return reify(this, flatMapFactory(this, mapper, context));\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, true));\n\t    },\n\t\n\t    fromEntrySeq: function() {\n\t      return new FromEntriesSequence(this);\n\t    },\n\t\n\t    get: function(searchKey, notSetValue) {\n\t      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n\t    },\n\t\n\t    getIn: function(searchKeyPath, notSetValue) {\n\t      var nested = this;\n\t      // Note: in an ES6 environment, we would prefer:\n\t      // for (var key of searchKeyPath) {\n\t      var iter = forceIterator(searchKeyPath);\n\t      var step;\n\t      while (!(step = iter.next()).done) {\n\t        var key = step.value;\n\t        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n\t        if (nested === NOT_SET) {\n\t          return notSetValue;\n\t        }\n\t      }\n\t      return nested;\n\t    },\n\t\n\t    groupBy: function(grouper, context) {\n\t      return groupByFactory(this, grouper, context);\n\t    },\n\t\n\t    has: function(searchKey) {\n\t      return this.get(searchKey, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    hasIn: function(searchKeyPath) {\n\t      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    isSubset: function(iter) {\n\t      iter = typeof iter.contains === 'function' ? iter : Iterable(iter);\n\t      return this.every(function(value ) {return iter.contains(value)});\n\t    },\n\t\n\t    isSuperset: function(iter) {\n\t      return iter.isSubset(this);\n\t    },\n\t\n\t    keySeq: function() {\n\t      return this.toSeq().map(keyMapper).toIndexedSeq();\n\t    },\n\t\n\t    last: function() {\n\t      return this.toSeq().reverse().first();\n\t    },\n\t\n\t    max: function(comparator) {\n\t      return maxFactory(this, comparator);\n\t    },\n\t\n\t    maxBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator, mapper);\n\t    },\n\t\n\t    min: function(comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n\t    },\n\t\n\t    minBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n\t    },\n\t\n\t    rest: function() {\n\t      return this.slice(1);\n\t    },\n\t\n\t    skip: function(amount) {\n\t      return this.slice(Math.max(0, amount));\n\t    },\n\t\n\t    skipLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, true));\n\t    },\n\t\n\t    skipUntil: function(predicate, context) {\n\t      return this.skipWhile(not(predicate), context);\n\t    },\n\t\n\t    sortBy: function(mapper, comparator) {\n\t      return reify(this, sortFactory(this, comparator, mapper));\n\t    },\n\t\n\t    take: function(amount) {\n\t      return this.slice(0, Math.max(0, amount));\n\t    },\n\t\n\t    takeLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().take(amount).reverse());\n\t    },\n\t\n\t    takeWhile: function(predicate, context) {\n\t      return reify(this, takeWhileFactory(this, predicate, context));\n\t    },\n\t\n\t    takeUntil: function(predicate, context) {\n\t      return this.takeWhile(not(predicate), context);\n\t    },\n\t\n\t    valueSeq: function() {\n\t      return this.toIndexedSeq();\n\t    },\n\t\n\t\n\t    // ### Hashable Object\n\t\n\t    hashCode: function() {\n\t      return this.__hash || (this.__hash = hashIterable(this));\n\t    },\n\t\n\t\n\t    // ### Internal\n\t\n\t    // abstract __iterate(fn, reverse)\n\t\n\t    // abstract __iterator(type, reverse)\n\t  });\n\t\n\t  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  var IterablePrototype = Iterable.prototype;\n\t  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n\t  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n\t  IterablePrototype.__toJS = IterablePrototype.toArray;\n\t  IterablePrototype.__toStringMapper = quoteString;\n\t  IterablePrototype.inspect =\n\t  IterablePrototype.toSource = function() { return this.toString(); };\n\t  IterablePrototype.chain = IterablePrototype.flatMap;\n\t\n\t  // Temporary warning about using length\n\t  (function () {\n\t    try {\n\t      Object.defineProperty(IterablePrototype, 'length', {\n\t        get: function () {\n\t          if (!Iterable.noLengthWarning) {\n\t            var stack;\n\t            try {\n\t              throw new Error();\n\t            } catch (error) {\n\t              stack = error.stack;\n\t            }\n\t            if (stack.indexOf('_wrapObject') === -1) {\n\t              console && console.warn && console.warn(\n\t                'iterable.length has been deprecated, '+\n\t                'use iterable.size or iterable.count(). '+\n\t                'This warning will become a silent error in a future version. ' +\n\t                stack\n\t              );\n\t              return this.size;\n\t            }\n\t          }\n\t        }\n\t      });\n\t    } catch (e) {}\n\t  })();\n\t\n\t\n\t\n\t  mixin(KeyedIterable, {\n\t\n\t    // ### More sequential methods\n\t\n\t    flip: function() {\n\t      return reify(this, flipFactory(this));\n\t    },\n\t\n\t    findKey: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry && entry[0];\n\t    },\n\t\n\t    findLastKey: function(predicate, context) {\n\t      return this.toSeq().reverse().findKey(predicate, context);\n\t    },\n\t\n\t    keyOf: function(searchValue) {\n\t      return this.findKey(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    lastKeyOf: function(searchValue) {\n\t      return this.findLastKey(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    mapEntries: function(mapper, context) {var this$0 = this;\n\t      var iterations = 0;\n\t      return reify(this,\n\t        this.toSeq().map(\n\t          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n\t        ).fromEntrySeq()\n\t      );\n\t    },\n\t\n\t    mapKeys: function(mapper, context) {var this$0 = this;\n\t      return reify(this,\n\t        this.toSeq().flip().map(\n\t          function(k, v)  {return mapper.call(context, k, v, this$0)}\n\t        ).flip()\n\t      );\n\t    },\n\t\n\t  });\n\t\n\t  var KeyedIterablePrototype = KeyedIterable.prototype;\n\t  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n\t  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n\t  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n\t  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return k + ': ' + quoteString(v)};\n\t\n\t\n\t\n\t  mixin(IndexedIterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, false);\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, false));\n\t    },\n\t\n\t    findIndex: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[0] : -1;\n\t    },\n\t\n\t    indexOf: function(searchValue) {\n\t      var key = this.toKeyedSeq().keyOf(searchValue);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    lastIndexOf: function(searchValue) {\n\t      return this.toSeq().reverse().indexOf(searchValue);\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, false));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, false));\n\t    },\n\t\n\t    splice: function(index, removeNum /*, ...values*/) {\n\t      var numArgs = arguments.length;\n\t      removeNum = Math.max(removeNum | 0, 0);\n\t      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n\t        return this;\n\t      }\n\t      index = resolveBegin(index, this.size);\n\t      var spliced = this.slice(0, index);\n\t      return reify(\n\t        this,\n\t        numArgs === 1 ?\n\t          spliced :\n\t          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n\t      );\n\t    },\n\t\n\t\n\t    // ### More collection methods\n\t\n\t    findLastIndex: function(predicate, context) {\n\t      var key = this.toKeyedSeq().findLastKey(predicate, context);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    first: function() {\n\t      return this.get(0);\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, false));\n\t    },\n\t\n\t    get: function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      return (index < 0 || (this.size === Infinity ||\n\t          (this.size !== undefined && index > this.size))) ?\n\t        notSetValue :\n\t        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n\t    },\n\t\n\t    has: function(index) {\n\t      index = wrapIndex(this, index);\n\t      return index >= 0 && (this.size !== undefined ?\n\t        this.size === Infinity || index < this.size :\n\t        this.indexOf(index) !== -1\n\t      );\n\t    },\n\t\n\t    interpose: function(separator) {\n\t      return reify(this, interposeFactory(this, separator));\n\t    },\n\t\n\t    interleave: function(/*...iterables*/) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n\t      var interleaved = zipped.flatten(true);\n\t      if (zipped.size) {\n\t        interleaved.size = zipped.size * iterables.length;\n\t      }\n\t      return reify(this, interleaved);\n\t    },\n\t\n\t    last: function() {\n\t      return this.get(-1);\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, false));\n\t    },\n\t\n\t    zip: function(/*, ...iterables */) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n\t    },\n\t\n\t    zipWith: function(zipper/*, ...iterables */) {\n\t      var iterables = arrCopy(arguments);\n\t      iterables[0] = this;\n\t      return reify(this, zipWithFactory(this, zipper, iterables));\n\t    },\n\t\n\t  });\n\t\n\t  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n\t  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t\n\t  mixin(SetIterable, {\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    get: function(value, notSetValue) {\n\t      return this.has(value) ? value : notSetValue;\n\t    },\n\t\n\t    contains: function(value) {\n\t      return this.has(value);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    keySeq: function() {\n\t      return this.valueSeq();\n\t    },\n\t\n\t  });\n\t\n\t  SetIterable.prototype.has = IterablePrototype.contains;\n\t\n\t\n\t  // Mixin subclasses\n\t\n\t  mixin(KeyedSeq, KeyedIterable.prototype);\n\t  mixin(IndexedSeq, IndexedIterable.prototype);\n\t  mixin(SetSeq, SetIterable.prototype);\n\t\n\t  mixin(KeyedCollection, KeyedIterable.prototype);\n\t  mixin(IndexedCollection, IndexedIterable.prototype);\n\t  mixin(SetCollection, SetIterable.prototype);\n\t\n\t\n\t  // #pragma Helper functions\n\t\n\t  function keyMapper(v, k) {\n\t    return k;\n\t  }\n\t\n\t  function entryMapper(v, k) {\n\t    return [k, v];\n\t  }\n\t\n\t  function not(predicate) {\n\t    return function() {\n\t      return !predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function neg(predicate) {\n\t    return function() {\n\t      return -predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function quoteString(value) {\n\t    return typeof value === 'string' ? JSON.stringify(value) : value;\n\t  }\n\t\n\t  function defaultZipper() {\n\t    return arrCopy(arguments);\n\t  }\n\t\n\t  function defaultNegComparator(a, b) {\n\t    return a < b ? 1 : a > b ? -1 : 0;\n\t  }\n\t\n\t  function hashIterable(iterable) {\n\t    if (iterable.size === Infinity) {\n\t      return 0;\n\t    }\n\t    var ordered = isOrdered(iterable);\n\t    var keyed = isKeyed(iterable);\n\t    var h = ordered ? 1 : 0;\n\t    var size = iterable.__iterate(\n\t      keyed ?\n\t        ordered ?\n\t          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n\t          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n\t        ordered ?\n\t          function(v ) { h = 31 * h + hash(v) | 0; } :\n\t          function(v ) { h = h + hash(v) | 0; }\n\t    );\n\t    return murmurHashOfSize(size, h);\n\t  }\n\t\n\t  function murmurHashOfSize(size, h) {\n\t    h = Math__imul(h, 0xCC9E2D51);\n\t    h = Math__imul(h << 15 | h >>> -15, 0x1B873593);\n\t    h = Math__imul(h << 13 | h >>> -13, 5);\n\t    h = (h + 0xE6546B64 | 0) ^ size;\n\t    h = Math__imul(h ^ h >>> 16, 0x85EBCA6B);\n\t    h = Math__imul(h ^ h >>> 13, 0xC2B2AE35);\n\t    h = smi(h ^ h >>> 16);\n\t    return h;\n\t  }\n\t\n\t  function hashMerge(a, b) {\n\t    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n\t  }\n\t\n\t  var Immutable = {\n\t\n\t    Iterable: Iterable,\n\t\n\t    Seq: Seq,\n\t    Collection: Collection,\n\t    Map: Map,\n\t    OrderedMap: OrderedMap,\n\t    List: List,\n\t    Stack: Stack,\n\t    Set: Set,\n\t    OrderedSet: OrderedSet,\n\t\n\t    Record: Record,\n\t    Range: Range,\n\t    Repeat: Repeat,\n\t\n\t    is: is,\n\t    fromJS: fromJS,\n\t\n\t  };\n\t\n\t  return Immutable;\n\t\n\t}));\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\tvar baseCopy = __webpack_require__(9),\n\t    keys = __webpack_require__(10);\n\t\n\t/**\n\t * The base implementation of `_.assign` without support for argument juggling,\n\t * multiple sources, and `this` binding `customizer` functions.\n\t *\n\t * @private\n\t * @param {Object} object The destination object.\n\t * @param {Object} source The source object.\n\t * @param {Function} [customizer] The function to customize assigning values.\n\t * @returns {Object} Returns the destination object.\n\t */\n\tfunction baseAssign(object, source, customizer) {\n\t  var props = keys(source);\n\t  if (!customizer) {\n\t    return baseCopy(source, object, props);\n\t  }\n\t  var index = -1,\n\t      length = props.length;\n\t\n\t  while (++index < length) {\n\t    var key = props[index],\n\t        value = object[key],\n\t        result = customizer(value, source[key], key, object, source);\n\t\n\t    if ((result === result ? result !== value : value === value) ||\n\t        (typeof value == 'undefined' && !(key in object))) {\n\t      object[key] = result;\n\t    }\n\t  }\n\t  return object;\n\t}\n\t\n\tmodule.exports = baseAssign;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\tvar bindCallback = __webpack_require__(11),\n\t    isIterateeCall = __webpack_require__(12);\n\t\n\t/**\n\t * Creates a function that assigns properties of source object(s) to a given\n\t * destination object.\n\t *\n\t * @private\n\t * @param {Function} assigner The function to assign values.\n\t * @returns {Function} Returns the new assigner function.\n\t */\n\tfunction createAssigner(assigner) {\n\t  return function() {\n\t    var length = arguments.length,\n\t        object = arguments[0];\n\t\n\t    if (length < 2 || object == null) {\n\t      return object;\n\t    }\n\t    if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {\n\t      length = 2;\n\t    }\n\t    // Juggle arguments.\n\t    if (length > 3 && typeof arguments[length - 2] == 'function') {\n\t      var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);\n\t    } else if (length > 2 && typeof arguments[length - 1] == 'function') {\n\t      customizer = arguments[--length];\n\t    }\n\t    var index = 0;\n\t    while (++index < length) {\n\t      var source = arguments[index];\n\t      if (source) {\n\t        assigner(object, source, customizer);\n\t      }\n\t    }\n\t    return object;\n\t  };\n\t}\n\t\n\tmodule.exports = createAssigner;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/**\n\t * Copies the properties of `source` to `object`.\n\t *\n\t * @private\n\t * @param {Object} source The object to copy properties from.\n\t * @param {Object} [object={}] The object to copy properties to.\n\t * @param {Array} props The property names to copy.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction baseCopy(source, object, props) {\n\t  if (!props) {\n\t    props = object;\n\t    object = {};\n\t  }\n\t  var index = -1,\n\t      length = props.length;\n\t\n\t  while (++index < length) {\n\t    var key = props[index];\n\t    object[key] = source[key];\n\t  }\n\t  return object;\n\t}\n\t\n\tmodule.exports = baseCopy;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\tvar isArguments = __webpack_require__(13),\n\t    isArray = __webpack_require__(14),\n\t    isNative = __webpack_require__(15);\n\t\n\t/** Used for native method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/** Native method references. */\n\tvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\t\n\t/* Native method references for those with the same name as other `lodash` methods. */\n\tvar nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;\n\t\n\t/**\n\t * Used as the maximum length of an array-like value.\n\t * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n\t * for more details.\n\t */\n\tvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t\n\t/**\n\t * An object environment feature flags.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @type Object\n\t */\n\tvar support = {};\n\t\n\t(function(x) {\n\t\n\t  /**\n\t   * Detect if `arguments` object indexes are non-enumerable.\n\t   *\n\t   * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object\n\t   * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat\n\t   * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`\n\t   * checks for indexes that exceed their function's formal parameters with\n\t   * associated values of `0`.\n\t   *\n\t   * @memberOf _.support\n\t   * @type boolean\n\t   */\n\t  try {\n\t    support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);\n\t  } catch(e) {\n\t    support.nonEnumArgs = true;\n\t  }\n\t}(0, 0));\n\t\n\t/**\n\t * Checks if `value` is a valid array-like index.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t */\n\tfunction isIndex(value, length) {\n\t  value = +value;\n\t  length = length == null ? MAX_SAFE_INTEGER : length;\n\t  return value > -1 && value % 1 == 0 && value < length;\n\t}\n\t\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * **Note:** This function is based on ES `ToLength`. See the\n\t * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n\t * for more details.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\t/**\n\t * A fallback implementation of `Object.keys` which creates an array of the\n\t * own enumerable property names of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to inspect.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction shimKeys(object) {\n\t  var props = keysIn(object),\n\t      propsLength = props.length,\n\t      length = propsLength && object.length;\n\t\n\t  var allowIndexes = length && isLength(length) &&\n\t    (isArray(object) || (support.nonEnumArgs && isArguments(object)));\n\t\n\t  var index = -1,\n\t      result = [];\n\t\n\t  while (++index < propsLength) {\n\t    var key = props[index];\n\t    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\t/**\n\t * Checks if `value` is the language type of `Object`.\n\t * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(1);\n\t * // => false\n\t */\n\tfunction isObject(value) {\n\t  // Avoid a V8 JIT bug in Chrome 19-20.\n\t  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t  var type = typeof value;\n\t  return type == 'function' || (value && type == 'object') || false;\n\t}\n\t\n\t/**\n\t * Creates an array of the own enumerable property names of `object`.\n\t *\n\t * **Note:** Non-object values are coerced to objects. See the\n\t * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)\n\t * for more details.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Object\n\t * @param {Object} object The object to inspect.\n\t * @returns {Array} Returns the array of property names.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t *   this.b = 2;\n\t * }\n\t *\n\t * Foo.prototype.c = 3;\n\t *\n\t * _.keys(new Foo);\n\t * // => ['a', 'b'] (iteration order is not guaranteed)\n\t *\n\t * _.keys('hi');\n\t * // => ['0', '1']\n\t */\n\tvar keys = !nativeKeys ? shimKeys : function(object) {\n\t  if (object) {\n\t    var Ctor = object.constructor,\n\t        length = object.length;\n\t  }\n\t  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n\t     (typeof object != 'function' && (length && isLength(length)))) {\n\t    return shimKeys(object);\n\t  }\n\t  return isObject(object) ? nativeKeys(object) : [];\n\t};\n\t\n\t/**\n\t * Creates an array of the own and inherited enumerable property names of `object`.\n\t *\n\t * **Note:** Non-object values are coerced to objects.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Object\n\t * @param {Object} object The object to inspect.\n\t * @returns {Array} Returns the array of property names.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t *   this.b = 2;\n\t * }\n\t *\n\t * Foo.prototype.c = 3;\n\t *\n\t * _.keysIn(new Foo);\n\t * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n\t */\n\tfunction keysIn(object) {\n\t  if (object == null) {\n\t    return [];\n\t  }\n\t  if (!isObject(object)) {\n\t    object = Object(object);\n\t  }\n\t  var length = object.length;\n\t  length = (length && isLength(length) &&\n\t    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;\n\t\n\t  var Ctor = object.constructor,\n\t      index = -1,\n\t      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n\t      result = Array(length),\n\t      skipIndexes = length > 0;\n\t\n\t  while (++index < length) {\n\t    result[index] = (index + '');\n\t  }\n\t  for (var key in object) {\n\t    if (!(skipIndexes && isIndex(key, length)) &&\n\t        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = keys;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/**\n\t * A specialized version of `baseCallback` which only supports `this` binding\n\t * and specifying the number of arguments to provide to `func`.\n\t *\n\t * @private\n\t * @param {Function} func The function to bind.\n\t * @param {*} thisArg The `this` binding of `func`.\n\t * @param {number} [argCount] The number of arguments to provide to `func`.\n\t * @returns {Function} Returns the callback.\n\t */\n\tfunction bindCallback(func, thisArg, argCount) {\n\t  if (typeof func != 'function') {\n\t    return identity;\n\t  }\n\t  if (typeof thisArg == 'undefined') {\n\t    return func;\n\t  }\n\t  switch (argCount) {\n\t    case 1: return function(value) {\n\t      return func.call(thisArg, value);\n\t    };\n\t    case 3: return function(value, index, collection) {\n\t      return func.call(thisArg, value, index, collection);\n\t    };\n\t    case 4: return function(accumulator, value, index, collection) {\n\t      return func.call(thisArg, accumulator, value, index, collection);\n\t    };\n\t    case 5: return function(value, other, key, object, source) {\n\t      return func.call(thisArg, value, other, key, object, source);\n\t    };\n\t  }\n\t  return function() {\n\t    return func.apply(thisArg, arguments);\n\t  };\n\t}\n\t\n\t/**\n\t * This method returns the first argument provided to it.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Utility\n\t * @param {*} value Any value.\n\t * @returns {*} Returns `value`.\n\t * @example\n\t *\n\t * var object = { 'user': 'fred' };\n\t * _.identity(object) === object;\n\t * // => true\n\t */\n\tfunction identity(value) {\n\t  return value;\n\t}\n\t\n\tmodule.exports = bindCallback;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/**\n\t * Used as the maximum length of an array-like value.\n\t * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n\t * for more details.\n\t */\n\tvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t\n\t/**\n\t * Checks if `value` is a valid array-like index.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t */\n\tfunction isIndex(value, length) {\n\t  value = +value;\n\t  length = length == null ? MAX_SAFE_INTEGER : length;\n\t  return value > -1 && value % 1 == 0 && value < length;\n\t}\n\t\n\t/**\n\t * Checks if the provided arguments are from an iteratee call.\n\t *\n\t * @private\n\t * @param {*} value The potential iteratee value argument.\n\t * @param {*} index The potential iteratee index or key argument.\n\t * @param {*} object The potential iteratee object argument.\n\t * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n\t */\n\tfunction isIterateeCall(value, index, object) {\n\t  if (!isObject(object)) {\n\t    return false;\n\t  }\n\t  var type = typeof index;\n\t  if (type == 'number') {\n\t    var length = object.length,\n\t        prereq = isLength(length) && isIndex(index, length);\n\t  } else {\n\t    prereq = type == 'string' && index in object;\n\t  }\n\t  return prereq && object[index] === value;\n\t}\n\t\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * **Note:** This function is based on ES `ToLength`. See the\n\t * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n\t * for more details.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\t/**\n\t * Checks if `value` is the language type of `Object`.\n\t * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(1);\n\t * // => false\n\t */\n\tfunction isObject(value) {\n\t  // Avoid a V8 JIT bug in Chrome 19-20.\n\t  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t  var type = typeof value;\n\t  return type == 'function' || (value && type == 'object') || false;\n\t}\n\t\n\tmodule.exports = isIterateeCall;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/** `Object#toString` result references. */\n\tvar argsTag = '[object Arguments]';\n\t\n\t/**\n\t * Checks if `value` is object-like.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t */\n\tfunction isObjectLike(value) {\n\t  return (value && typeof value == 'object') || false;\n\t}\n\t\n\t/** Used for native method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/**\n\t * Used to resolve the `toStringTag` of values.\n\t * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n\t * for more details.\n\t */\n\tvar objToString = objectProto.toString;\n\t\n\t/**\n\t * Used as the maximum length of an array-like value.\n\t * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n\t * for more details.\n\t */\n\tvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\t/**\n\t * Checks if `value` is classified as an `arguments` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t * @example\n\t *\n\t * (function() { return _.isArguments(arguments); })();\n\t * // => true\n\t *\n\t * _.isArguments([1, 2, 3]);\n\t * // => false\n\t */\n\tfunction isArguments(value) {\n\t  var length = isObjectLike(value) ? value.length : undefined;\n\t  return (isLength(length) && objToString.call(value) == argsTag) || false;\n\t}\n\t\n\tmodule.exports = isArguments;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/** `Object#toString` result references. */\n\tvar arrayTag = '[object Array]',\n\t    funcTag = '[object Function]';\n\t\n\t/** Used to detect host constructors (Safari > 5). */\n\tvar reHostCtor = /^\\[object .+?Constructor\\]$/;\n\t\n\t/**\n\t * Used to match `RegExp` special characters.\n\t * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)\n\t * for more details.\n\t */\n\tvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n\t    reHasRegExpChars = RegExp(reRegExpChars.source);\n\t\n\t/**\n\t * Converts `value` to a string if it is not one. An empty string is returned\n\t * for `null` or `undefined` values.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */\n\tfunction baseToString(value) {\n\t  if (typeof value == 'string') {\n\t    return value;\n\t  }\n\t  return value == null ? '' : (value + '');\n\t}\n\t\n\t/**\n\t * Checks if `value` is object-like.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t */\n\tfunction isObjectLike(value) {\n\t  return (value && typeof value == 'object') || false;\n\t}\n\t\n\t/** Used for native method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to resolve the decompiled source of functions. */\n\tvar fnToString = Function.prototype.toString;\n\t\n\t/**\n\t * Used to resolve the `toStringTag` of values.\n\t * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n\t * for more details.\n\t */\n\tvar objToString = objectProto.toString;\n\t\n\t/** Used to detect if a method is native. */\n\tvar reNative = RegExp('^' +\n\t  escapeRegExp(objToString)\n\t  .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t);\n\t\n\t/* Native method references for those with the same name as other `lodash` methods. */\n\tvar nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;\n\t\n\t/**\n\t * Used as the maximum length of an array-like value.\n\t * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n\t * for more details.\n\t */\n\tvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\t/**\n\t * Checks if `value` is classified as an `Array` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t * @example\n\t *\n\t * _.isArray([1, 2, 3]);\n\t * // => true\n\t *\n\t * (function() { return _.isArray(arguments); })();\n\t * // => false\n\t */\n\tvar isArray = nativeIsArray || function(value) {\n\t  return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;\n\t};\n\t\n\t/**\n\t * Checks if `value` is a native function.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n\t * @example\n\t *\n\t * _.isNative(Array.prototype.push);\n\t * // => true\n\t *\n\t * _.isNative(_);\n\t * // => false\n\t */\n\tfunction isNative(value) {\n\t  if (value == null) {\n\t    return false;\n\t  }\n\t  if (objToString.call(value) == funcTag) {\n\t    return reNative.test(fnToString.call(value));\n\t  }\n\t  return (isObjectLike(value) && reHostCtor.test(value)) || false;\n\t}\n\t\n\t/**\n\t * Escapes the `RegExp` special characters \"\\\", \"^\", \"$\", \".\", \"|\", \"?\", \"*\",\n\t * \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category String\n\t * @param {string} [string=''] The string to escape.\n\t * @returns {string} Returns the escaped string.\n\t * @example\n\t *\n\t * _.escapeRegExp('[lodash](https://lodash.com/)');\n\t * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n\t */\n\tfunction escapeRegExp(string) {\n\t  string = baseToString(string);\n\t  return (string && reHasRegExpChars.test(string))\n\t    ? string.replace(reRegExpChars, '\\\\$&')\n\t    : string;\n\t}\n\t\n\tmodule.exports = isArray;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/** `Object#toString` result references. */\n\tvar funcTag = '[object Function]';\n\t\n\t/** Used to detect host constructors (Safari > 5). */\n\tvar reHostCtor = /^\\[object .+?Constructor\\]$/;\n\t\n\t/**\n\t * Used to match `RegExp` special characters.\n\t * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)\n\t * for more details.\n\t */\n\tvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n\t    reHasRegExpChars = RegExp(reRegExpChars.source);\n\t\n\t/**\n\t * Converts `value` to a string if it is not one. An empty string is returned\n\t * for `null` or `undefined` values.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */\n\tfunction baseToString(value) {\n\t  if (typeof value == 'string') {\n\t    return value;\n\t  }\n\t  return value == null ? '' : (value + '');\n\t}\n\t\n\t/**\n\t * Checks if `value` is object-like.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t */\n\tfunction isObjectLike(value) {\n\t  return (value && typeof value == 'object') || false;\n\t}\n\t\n\t/** Used for native method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to resolve the decompiled source of functions. */\n\tvar fnToString = Function.prototype.toString;\n\t\n\t/**\n\t * Used to resolve the `toStringTag` of values.\n\t * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n\t * for more details.\n\t */\n\tvar objToString = objectProto.toString;\n\t\n\t/** Used to detect if a method is native. */\n\tvar reNative = RegExp('^' +\n\t  escapeRegExp(objToString)\n\t  .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t);\n\t\n\t/**\n\t * Checks if `value` is a native function.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n\t * @example\n\t *\n\t * _.isNative(Array.prototype.push);\n\t * // => true\n\t *\n\t * _.isNative(_);\n\t * // => false\n\t */\n\tfunction isNative(value) {\n\t  if (value == null) {\n\t    return false;\n\t  }\n\t  if (objToString.call(value) == funcTag) {\n\t    return reNative.test(fnToString.call(value));\n\t  }\n\t  return (isObjectLike(value) && reHostCtor.test(value)) || false;\n\t}\n\t\n\t/**\n\t * Escapes the `RegExp` special characters \"\\\", \"^\", \"$\", \".\", \"|\", \"?\", \"*\",\n\t * \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category String\n\t * @param {string} [string=''] The string to escape.\n\t * @returns {string} Returns the escaped string.\n\t * @example\n\t *\n\t * _.escapeRegExp('[lodash](https://lodash.com/)');\n\t * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n\t */\n\tfunction escapeRegExp(string) {\n\t  string = baseToString(string);\n\t  return (string && reHasRegExpChars.test(string))\n\t    ? string.replace(reRegExpChars, '\\\\$&')\n\t    : string;\n\t}\n\t\n\tmodule.exports = isNative;\n\n\n/***/ }\n/******/ ])\n});\n\n\n\n/** WEBPACK FOOTER **\n ** flux2.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap bca32a7057b65786c497\n **/","/* global require, module */\n'use strict';\nvar Dispatcher = require('./lib/dispatcher');\nvar createStore = require('./lib/create-store');\n\nmodule.exports = {\n    Dispatcher: Dispatcher,\n    createStore: createStore(Dispatcher)\n};\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","/* global require, module */\n'use strict';\n\n// @todo make [id] argument as an optional\nmodule.exports = {\n    /**\n     * Turn on to enable logging\n     * @type {boolean}\n     */\n    debugLog: false,\n    /**\n     * Hash of registered stores (indexed by `name` property)\n     * @type {object}\n     * @private\n     */\n    _registeredStoresByName: {},\n    /**\n     * Hash of registered stores (indexed by `_ID` property)\n     * @type {object}\n     * @private\n     */\n    _registeredStoresByID: {},\n    /**\n     * @type {number}\n     * @private\n     */\n    _lastRegisteredStoreID: 0,\n    /**\n     * @param {string} id of collection\n     * @param {function} callback which can return Promise object\n     * @param {object} [context]\n     * @param {object} [options]\n     * @param {boolean} [options.once=false]\n     * @param {boolean} [options.fullState=false]\n     * @returns {object} this\n     */\n    register: function (id, callback, context, options) {\n        this['callbacks'] = this['callbacks'] || {};\n        var itemIdCounter = this['callbacksSubscriberIdCounter'] || 1;\n        var exists = false;\n        var collection = this['callbacks'][id] || {};\n        _.forOwn(collection, function (collectionItem) {\n            if (collectionItem && collectionItem.callback === callback) {\n                exists = true;\n            }\n        });\n        if (!exists) {\n            collection[itemIdCounter++] = {\n                callback: callback,\n                context: context || this,\n                options: (typeof options === 'object') || {}\n            };\n            this['callbacks'][id] = collection;\n            this['callbacksSubscriberIdCounter'] = itemIdCounter;\n        }\n        return this;\n    },\n\n    /**\n     * @param {string} id of collection\n     * @param {function} callback\n     * @param {object} [context]\n     * @returns {object} this\n     */\n    registerOnce: function (id, callback, context) {\n        this.register(id, callback, context, {once: true});\n    },\n\n    /**\n     * @param {string|object[]} id of action or a collection {action: '', data: {}}\n     * @param {object} [data] to action\n     * @returns {object} this\n     * @todo support promises as a return value\n     */\n    dispatch: function (id, data) {\n        if (this['callbacks'] && this['callbacks'][id]) {\n\n            var collection = this['callbacks'][id];\n            var itemsToDelete = [];\n\n            _.forOwn(collection, function (collectionItem, collectionItemId) {\n                if (collectionItem && typeof collectionItem.callback === 'function') {\n                    collectionItem.callback.apply(collectionItem.context, data && [data]);\n                    if (collectionItem.options.once) {\n                        itemsToDelete.push(collectionItemId);\n                    }\n                }\n            });\n            for (var index = 0, length = itemsToDelete.length; index < length; index++) {\n                delete collection[itemsToDelete[index]];\n            }\n        }\n        return this;\n    },\n\n    /**\n     * @param {string} id of collection\n     * @param {function} callback\n     * @returns {object} this\n     */\n    unregister: function (id, callback) {\n        if (this['callbacks'] && this['callbacks'][id]) {\n            var collection = this['callbacks'][id];\n            _.forOwn(collection, function (collectionItem, id) {\n                if (collectionItem.callback === callback) {\n                    delete collection[id];\n                }\n            });\n        }\n        return this;\n    },\n\n    /**\n     * Provides wait for store changes feature\n     * @param {object|object[]} chains\n     * @param {object} [chains.store] store object\n     * @param {function} [chains.ready] callback which should return true when params are accepted\n     * @param {function} callback - calls when all parts in chain are accepted\n     * @example\n     *   Dispatcher.waitFor([{\n     *     store: commentsStore,\n     *     ready: function (params) {\n     *       return Array.isArray(params.comments);\n      *    }\n      *  }, {\n      *    store: activeUsersStore,\n      *    ready: function (params) {\n      *      return Array.isArray(params.users);\n      *    }\n      *  }], function () {\n      *    React.render(\n      *      React.createElement(MainPage, null),\n      *      document.body\n      *    );\n      *  });\n     */\n    waitFor: function (chains, callback) {\n        var chains = Array.isArray(chains) ? chains : [chains];\n        var context = {\n            counter: 0,\n            chains: chains,\n            callback: callback\n        };\n        for (var index = 0, length = chains.length; index < length; index++) {\n            context.counter++;\n            chains[index].store.on('change', _onWaitForStoreChange, context);\n        }\n        if (context.counter === 0 && typeof callback === 'function') {\n            callback();\n        }\n    },\n    /**\n     * @param {object} store\n     * @returns {number} id of registered store\n     */\n    _registerStore: function (store) {\n        if (this.debugLog && console.debug) {\n            console.debug('Dispatcher.registerStore(%s)', store.name || 'unknown', store);\n        }\n        this._lastRegisteredStoreID++;\n        store._registeredStoreID = this._lastRegisteredStoreID;\n        this._registeredStoresByID[store._registeredStoreID] = store;\n        if (typeof store.name !== 'undefined') {\n            var name = store.name;\n            if (this._registeredStoresByName[name]) {\n                if (this._registeredStoresByName[name] !== store) {\n                    if (console.warn) {\n                        console.warn(\n                            'Another store with specified name \"%s\" is already registered.',\n                            name,\n                            this._registeredStoresByName[name]\n                        );\n                    }\n                }\n            } else {\n                this._registeredStoresByName[name] = store;\n            }\n        }\n    },\n    /**\n     * @param {string|number} identifier - name or id of store\n     */\n    _unregisterStore: function (identifier) {\n        var store = this.getStore(identifier);\n        if (this.debugLog && console.debug) {\n            console.debug('Dispatcher.unregisterStore(%s)', store.name || 'unknown', store);\n        }\n        if (store.name) {\n            delete this._registeredStoresByName[store.name];\n        }\n        if (store._registeredStoreID) {\n            delete this._registeredStoresByID[store._registeredStoreID];\n        }\n    },\n    /**\n     * Returns object of specified store\n     * @param {string|number} identifier - name or id of store\n     * @returns {object} found store or false\n     */\n    getStore: function (identifier) {\n        if (typeof identifier === 'number' &&\n                this._registeredStoresByID[identifier]) {\n            return this._registeredStoresByID[identifier];\n        } else if (this._registeredStoresByName[identifier]) {\n            return this._registeredStoresByName[identifier];\n        } else {\n            return false;\n        }\n    },\n    /**\n     * Returns `state` property of specified store\n     * @param {string|number} identifier - name or id of store\n     */\n    getState: function (identifier) {\n        var foundStore = this.getStore(identifier);\n        if (typeof foundStore === 'object') {\n            return foundStore.state;\n        } else {\n            return false;\n        }\n    },\n    /**\n     * Set state of specified store\n     * @param {string|number} identifier - name or id of store\n     * @param {object} state\n     */\n    setState: function (identifier, state) {\n        if (this.debugLog && console.debug) {\n            console.debug('Dispatcher.setState(%s)', identifier, state);\n        }\n        var foundStore = this.getStore(identifier);\n        if (foundStore.name) {\n            this.dispatch('set' + foundStore.name + 'State', state);\n        }\n        this.dispatch('setStore' + foundStore._registeredStoreID + 'State', state);\n        foundStore.setState(state);\n    }\n};\n/**\n * Uses by waitFor() method\n * @param {Object} changes\n * @private\n */\nvar _onWaitForStoreChange = function (changes) {\n    var chain;\n    for (var key in this.chains) {\n        chain = this.chains[key];\n        if (!this.chains.hasOwnProperty(key) || chain.store !== this) {\n            continue;\n        }\n        if (chain.ready(changes)) {\n            chain.store.off('change', _onWaitForStoreChange);\n            chain.counter--;\n            if (chain.counter < 1 && typeof callback === 'function') {\n                chain.callback();\n            }\n        }\n        break;\n    }\n};\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/dispatcher.js\n **/","/* global require, module */\nvar EventEmitter = require('eventemitter3');\nvar inherites = require('inherits');\nvar assign = require('lodash.assign');\nvar Immutable = require('immutable');\n\n/**\n * @param {Object} Dispatcher\n * @returns {Function}\n */\nmodule.exports = function (Dispatcher) {\n    /**\n     * Creates a store instance\n     * @constructor\n     * @param {object} spec\n     * @param {string} [spec.name]\n     * @param {function} [spec.getInitialState]\n     * @parma {function} [spec.storeWillMount]\n     * @parma {function} [spec.storeDidMount]\n     * @param {function} [spec.shouldStoreUpdate]\n     * @param {function} [spec.storeWillUpdate]\n     * @param {function} [spec.storeDidUpdate]\n     * @returns {object} instance\n     */\n    var Store = function (spec) {\n        assign(this, spec);\n        if (typeof this.getInitialState === 'function') {\n            this._stateMap = Immutable.Map(this.getInitialState());\n            this.state = this._stateMap.toJS();\n        } else {\n            this._stateMap = Immutable.Map({});\n            this.state = {};\n        }\n        if (typeof this.init !== 'undefined') {\n            this.init();\n            if (console.warn) {\n                console.warn(\n                    'You use deprecated property init() to construct store. ' +\n                    'Please use getInitialState() instead.',\n                    this\n                );\n            }\n        }\n        if (typeof this.storeWillMount === 'function') {\n            var cancel = this.storeWillMount();\n            if (cancel) {\n                return null;\n            }\n        }\n        Dispatcher._registerStore(this);\n        if (typeof this.storeDidMount === 'function') {\n            this.storeDidMount();\n        }\n    };\n    inherites(Store, EventEmitter);\n    /**\n     * @param {Boolean} state\n     * @returns {boolean}\n     */\n    Store.prototype.setState = function (state) {\n        if (typeof this.shouldStoreUpdate === 'function') {\n            if (!this.shouldStoreUpdate(state)) {\n                return false;\n            }\n        }\n        var prevState = this._stateMap;\n        var newState = prevState.merge(state);\n        if (typeof this.storeWillUpdate === 'function') {\n            this.storeWillUpdate(newState);\n        }\n        this._stateMap = newState;\n        this.state = newState.toJS();\n        this.emit('change', newState);\n        if (typeof this.storeDidUpdate === 'function') {\n            this.storeDidUpdate(prevState.toJS());\n        }\n    };\n    Store.prototype.appendStore = function (changes) {\n        var state = this._stateMap.toJS();\n        var mergedArrays = {};\n        for (var key in changes) {\n            if (!changes.hasOwnProperty(key)) continue;\n            if (Array.isArray(changes[key]) &&\n                Array.isArray(state[key])) {\n                var mergedValue = state[key].concat(changes[key]);\n                mergedArrays[key] = mergedValue;\n            }\n        }\n        var newState = this._stateMap.merge(state, changes, mergedArrays);\n        this.setState(newState);\n    };\n    return function (spec) {\n        return new Store(spec);\n    };\n};\n\n\n/** WEBPACK FOOTER **\n ** ./lib/create-store.js\n **/","'use strict';\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  if (!this._events || !this._events[event]) return [];\n  if (this._events[event].fn) return [this._events[event].fn];\n\n  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {\n    ee[i] = this._events[event][i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  if (!this._events || !this._events[event]) return false;\n\n  var listeners = this._events[event]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n  if (!this._events || !this._events[event]) return this;\n\n  var listeners = this._events[event]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {\n      events.push(listeners);\n    }\n    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {\n      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {\n        events.push(listeners[i]);\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[event] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[event];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[event];\n  else this._events = {};\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the module.\n//\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.EventEmitter2 = EventEmitter;\nEventEmitter.EventEmitter3 = EventEmitter;\n\n//\n// Expose the module.\n//\nmodule.exports = EventEmitter;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eventemitter3/index.js\n **/","/**\n * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar baseAssign = require('lodash._baseassign'),\n    createAssigner = require('lodash._createassigner');\n\n/**\n * Assigns own enumerable properties of source object(s) to the destination\n * object. Subsequent sources overwrite property assignments of previous sources.\n * If `customizer` is provided it is invoked to produce the assigned values.\n * The `customizer` is bound to `thisArg` and invoked with five arguments;\n * (objectValue, sourceValue, key, object, source).\n *\n * @static\n * @memberOf _\n * @alias extend\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @param {Function} [customizer] The function to customize assigning values.\n * @param {*} [thisArg] The `this` binding of `customizer`.\n * @returns {Object} Returns `object`.\n * @example\n *\n * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n * // => { 'user': 'fred', 'age': 40 }\n *\n * // using a customizer callback\n * var defaults = _.partialRight(_.assign, function(value, other) {\n *   return typeof value == 'undefined' ? other : value;\n * });\n *\n * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n * // => { 'user': 'barney', 'age': 36 }\n */\nvar assign = createAssigner(baseAssign);\n\nmodule.exports = assign;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash.assign/index.js\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/inherits/inherits_browser.js\n **/","/**\n *  Copyright (c) 2014, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Immutable = factory()\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    return index >= 0 ? (+index) : ensureSize(iter) + (+index);\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function Iterator(next) {\n      this.next = next;\n    }\n\n    Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect =\n  Iterator.prototype.toSource = function () { return this.toString(); }\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.of = function(/*...values*/) {\n      return KeyedSeq(arguments);\n    };\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n    KeyedSeq.prototype.toSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  // #pragma Root Sequences\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n    }\n    return typeof valueA.equals === 'function' &&\n      typeof valueB.equals === 'function' ?\n        valueA.equals(valueB) :\n        valueA === valueB || (valueA !== valueA && valueB !== valueB);\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && value.constructor === Object;\n  }\n\n  var Math__imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function Math__imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    return hashJSObj(o);\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash = weakMap && weakMap.get(obj);\n    if (hash) return hash;\n\n    hash = obj[UID_HASH_KEY];\n    if (hash) return hash;\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash) return hash;\n\n      hash = getIENodeHash(obj);\n      if (hash) return hash;\n    }\n\n    if (Object.isExtensible && !Object.isExtensible(obj)) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (weakMap) {\n      weakMap.set(obj, hash);\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, 'x', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var weakMap = typeof WeakMap === 'function' && new WeakMap();\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.contains = function(value) {\n      return this._iter.contains(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.contains(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          return fn(entry[1], entry[0], this$0);\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            return type === ITERATE_ENTRIES ? step :\n              iteratorValue(type, entry[0], entry[1], step);\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.contains(key)};\n    flipSequence.contains = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.contains = function(value ) {return iterable.contains(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    var sliceSize = resolvedEnd - resolvedBegin;\n    if (sliceSize < 0) {\n      sliceSize = 0;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (skipped++ !== resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(keyPath, emptyMap(), function(m ) {return m.merge.apply(m, iters)});\n    };\n\n    Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger(undefined), arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMerger(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(keyPath, emptyMap(), function(m ) {return m.mergeDeep.apply(m, iters)});\n    };\n\n    Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(merger) {\n    return function(existing, value) \n      {return existing && existing.mergeDeepWith && isIterable(value) ?\n        existing.mergeDeepWith(merger, value) :\n        merger ? merger(existing, value) : value};\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index < 0 || index >= this.size) {\n        return notSetValue;\n      }\n      index += this._origin;\n      var node = listNodeFor(this, index);\n      return node && node.array[index & MASK];\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger(undefined), arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMerger(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n      var removingLast = sizeIndex === this.array.length - 1;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingLast) {\n          return this;\n        }\n      }\n      if (removingLast && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingLast) {\n        editable.array.pop();\n      }\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might require creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might require creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.toSeq().cacheResult.__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.toSeq().cacheResult().__iterator(type, reverse);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.contains(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.contains(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var RecordType = function Record(values) {\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        this._map = Map(values);\n      };\n\n      var keys = Object.keys(defaultValues);\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n      name && (RecordTypePrototype._name = name);\n      RecordTypePrototype._defaultValues = defaultValues;\n      RecordTypePrototype._keys = keys;\n      RecordTypePrototype.size = keys.length;\n\n      try {\n        keys.forEach(function(key ) {\n          Object.defineProperty(RecordType.prototype, key, {\n            get: function() {\n              return this.get(key);\n            },\n            set: function(value) {\n              invariant(this.__ownerID, 'Cannot set on an immutable record.');\n              this.set(key, value);\n            }\n          });\n        });\n      } catch (error) {\n        // Object.defineProperty failed. Probably IE8.\n      }\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var SuperRecord = Object.getPrototypeOf(this).constructor;\n      return SuperRecord._empty || (SuperRecord._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        a.cacheResult();\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step > 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.contains = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.contains = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    contains: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    findEntry: function(predicate, context) {\n      var found;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findLastEntry: function(predicate, context) {\n      return this.toSeq().reverse().findEntry(predicate, context);\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.contains === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.contains(value)});\n    },\n\n    isSuperset: function(iter) {\n      return iter.isSubset(this);\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    },\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n\n  // Temporary warning about using length\n  (function () {\n    try {\n      Object.defineProperty(IterablePrototype, 'length', {\n        get: function () {\n          if (!Iterable.noLengthWarning) {\n            var stack;\n            try {\n              throw new Error();\n            } catch (error) {\n              stack = error.stack;\n            }\n            if (stack.indexOf('_wrapObject') === -1) {\n              console && console.warn && console.warn(\n                'iterable.length has been deprecated, '+\n                'use iterable.size or iterable.count(). '+\n                'This warning will become a silent error in a future version. ' +\n                stack\n              );\n              return this.size;\n            }\n          }\n        }\n      });\n    } catch (e) {}\n  })();\n\n\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toSeq().reverse().findKey(predicate, context);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.findLastKey(function(value ) {return is(value, searchValue)});\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    },\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return k + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.toKeyedSeq().keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      return this.toSeq().reverse().indexOf(searchValue);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      index = resolveBegin(index, this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var key = this.toKeyedSeq().findLastKey(predicate, context);\n      return key === undefined ? -1 : key;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    },\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    contains: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    },\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.contains;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : value;\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = Math__imul(h, 0xCC9E2D51);\n    h = Math__imul(h << 15 | h >>> -15, 0x1B873593);\n    h = Math__imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = Math__imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = Math__imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS,\n\n  };\n\n  return Immutable;\n\n}));\n\n\n/** WEBPACK FOOTER **\n ** ./~/immutable/dist/immutable.js\n **/","/**\n * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar baseCopy = require('lodash._basecopy'),\n    keys = require('lodash.keys');\n\n/**\n * The base implementation of `_.assign` without support for argument juggling,\n * multiple sources, and `this` binding `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {Function} [customizer] The function to customize assigning values.\n * @returns {Object} Returns the destination object.\n */\nfunction baseAssign(object, source, customizer) {\n  var props = keys(source);\n  if (!customizer) {\n    return baseCopy(source, object, props);\n  }\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index],\n        value = object[key],\n        result = customizer(value, source[key], key, object, source);\n\n    if ((result === result ? result !== value : value === value) ||\n        (typeof value == 'undefined' && !(key in object))) {\n      object[key] = result;\n    }\n  }\n  return object;\n}\n\nmodule.exports = baseAssign;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash.assign/~/lodash._baseassign/index.js\n **/","/**\n * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar bindCallback = require('lodash._bindcallback'),\n    isIterateeCall = require('lodash._isiterateecall');\n\n/**\n * Creates a function that assigns properties of source object(s) to a given\n * destination object.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return function() {\n    var length = arguments.length,\n        object = arguments[0];\n\n    if (length < 2 || object == null) {\n      return object;\n    }\n    if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {\n      length = 2;\n    }\n    // Juggle arguments.\n    if (length > 3 && typeof arguments[length - 2] == 'function') {\n      var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);\n    } else if (length > 2 && typeof arguments[length - 1] == 'function') {\n      customizer = arguments[--length];\n    }\n    var index = 0;\n    while (++index < length) {\n      var source = arguments[index];\n      if (source) {\n        assigner(object, source, customizer);\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createAssigner;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash.assign/~/lodash._createassigner/index.js\n **/","/**\n * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Copies the properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Array} props The property names to copy.\n * @returns {Object} Returns `object`.\n */\nfunction baseCopy(source, object, props) {\n  if (!props) {\n    props = object;\n    object = {};\n  }\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    object[key] = source[key];\n  }\n  return object;\n}\n\nmodule.exports = baseCopy;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash.assign/~/lodash._baseassign/~/lodash._basecopy/index.js\n **/","/**\n * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar isArguments = require('lodash.isarguments'),\n    isArray = require('lodash.isarray'),\n    isNative = require('lodash.isnative');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Native method references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;\n\n/**\n * Used as the maximum length of an array-like value.\n * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * for more details.\n */\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * An object environment feature flags.\n *\n * @static\n * @memberOf _\n * @type Object\n */\nvar support = {};\n\n(function(x) {\n\n  /**\n   * Detect if `arguments` object indexes are non-enumerable.\n   *\n   * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object\n   * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat\n   * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`\n   * checks for indexes that exceed their function's formal parameters with\n   * associated values of `0`.\n   *\n   * @memberOf _.support\n   * @type boolean\n   */\n  try {\n    support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);\n  } catch(e) {\n    support.nonEnumArgs = true;\n  }\n}(0, 0));\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = +value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on ES `ToLength`. See the\n * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n * for more details.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = length && isLength(length) &&\n    (isArray(object) || (support.nonEnumArgs && isArguments(object)));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is the language type of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type == 'function' || (value && type == 'object') || false;\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to inspect.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  if (object) {\n    var Ctor = object.constructor,\n        length = object.length;\n  }\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n     (typeof object != 'function' && (length && isLength(length)))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to inspect.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keys;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash.assign/~/lodash._baseassign/~/lodash.keys/index.js\n **/","/**\n * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * A specialized version of `baseCallback` which only supports `this` binding\n * and specifying the number of arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  if (typeof thisArg == 'undefined') {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\n/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = bindCallback;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash.assign/~/lodash._createassigner/~/lodash._bindcallback/index.js\n **/","/**\n * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Used as the maximum length of an array-like value.\n * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * for more details.\n */\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = +value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if the provided arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number') {\n    var length = object.length,\n        prereq = isLength(length) && isIndex(index, length);\n  } else {\n    prereq = type == 'string' && index in object;\n  }\n  return prereq && object[index] === value;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on ES `ToLength`. See the\n * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n * for more details.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the language type of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type == 'function' || (value && type == 'object') || false;\n}\n\nmodule.exports = isIterateeCall;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash.assign/~/lodash._createassigner/~/lodash._isiterateecall/index.js\n **/","/**\n * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return (value && typeof value == 'object') || false;\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the `toStringTag` of values.\n * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * for more details.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Used as the maximum length of an array-like value.\n * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n * for more details.\n */\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is classified as an `arguments` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * (function() { return _.isArguments(arguments); })();\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  var length = isObjectLike(value) ? value.length : undefined;\n  return (isLength(length) && objToString.call(value) == argsTag) || false;\n}\n\nmodule.exports = isArguments;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash.assign/~/lodash._baseassign/~/lodash.keys/~/lodash.isarguments/index.js\n **/","/**\n * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]',\n    funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Used to match `RegExp` special characters.\n * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)\n * for more details.\n */\nvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n    reHasRegExpChars = RegExp(reRegExpChars.source);\n\n/**\n * Converts `value` to a string if it is not one. An empty string is returned\n * for `null` or `undefined` values.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  if (typeof value == 'string') {\n    return value;\n  }\n  return value == null ? '' : (value + '');\n}\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return (value && typeof value == 'object') || false;\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/**\n * Used to resolve the `toStringTag` of values.\n * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * for more details.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reNative = RegExp('^' +\n  escapeRegExp(objToString)\n  .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;\n\n/**\n * Used as the maximum length of an array-like value.\n * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n * for more details.\n */\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * (function() { return _.isArray(arguments); })();\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;\n};\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (objToString.call(value) == funcTag) {\n    return reNative.test(fnToString.call(value));\n  }\n  return (isObjectLike(value) && reHostCtor.test(value)) || false;\n}\n\n/**\n * Escapes the `RegExp` special characters \"\\\", \"^\", \"$\", \".\", \"|\", \"?\", \"*\",\n * \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n *\n * @static\n * @memberOf _\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n */\nfunction escapeRegExp(string) {\n  string = baseToString(string);\n  return (string && reHasRegExpChars.test(string))\n    ? string.replace(reRegExpChars, '\\\\$&')\n    : string;\n}\n\nmodule.exports = isArray;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash.assign/~/lodash._baseassign/~/lodash.keys/~/lodash.isarray/index.js\n **/","/**\n * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Used to match `RegExp` special characters.\n * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)\n * for more details.\n */\nvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n    reHasRegExpChars = RegExp(reRegExpChars.source);\n\n/**\n * Converts `value` to a string if it is not one. An empty string is returned\n * for `null` or `undefined` values.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  if (typeof value == 'string') {\n    return value;\n  }\n  return value == null ? '' : (value + '');\n}\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return (value && typeof value == 'object') || false;\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/**\n * Used to resolve the `toStringTag` of values.\n * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * for more details.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reNative = RegExp('^' +\n  escapeRegExp(objToString)\n  .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (objToString.call(value) == funcTag) {\n    return reNative.test(fnToString.call(value));\n  }\n  return (isObjectLike(value) && reHostCtor.test(value)) || false;\n}\n\n/**\n * Escapes the `RegExp` special characters \"\\\", \"^\", \"$\", \".\", \"|\", \"?\", \"*\",\n * \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n *\n * @static\n * @memberOf _\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n */\nfunction escapeRegExp(string) {\n  string = baseToString(string);\n  return (string && reHasRegExpChars.test(string))\n    ? string.replace(reRegExpChars, '\\\\$&')\n    : string;\n}\n\nmodule.exports = isNative;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/lodash.assign/~/lodash._baseassign/~/lodash.keys/~/lodash.isnative/index.js\n **/"],"sourceRoot":""}